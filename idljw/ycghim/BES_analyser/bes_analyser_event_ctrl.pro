;===================================================================================
;
; This file contains following functions and procedures to control the events 
;   generated by windows for bes_analyser:
;
;  1) bes_analyser_err_msg_window_event
;     --> to control events generated by bes_analyser_err_msg_window
;
;  2) IDL_msg_box_window_event
;     --> to control events generated by IDL_msg_box_window
;
;  3) CUDA_comm_window_event
;     --> to control events generated by CUDA_comm_window
;
;  4) update_time_sel_window
;     --> update the fileds information on time_sel_window
;
;  5) time_sel_window_event
;     --> to control events gererated by time_sel_window
;
;  6) time_file_sel_window_event
;     --> to control events generated by time_file_sel_window
;
;  7) save_options_window_event
;     --> to control events generate by save_options_window
;
;  8) load_options_window_event
;     --> to control events generate by load_options_window
;
;  9) update_bes_time_evol_window
;     --> update the fields information on bes_time_evol_window
;
;  10) bes_time_evol_window_event
;     --> to contol events generated by bes_time_evol_window
;
;  11) update_rms_dc_time_evol_window
;     --> update the fields information on bes_rms_dc_time_evol_window
;
;  12) bes_rms_dc_time_evol_window_event
;     --> to control events generated by bes_rms_dc_time_evol_window
;
;  13) update_bes_animation_window
;     --> to update the fields information on bes_animaiton_window
;
;  14) bes_animation_window_event
;      --> to control events generated by bes_animation_window
;
;  15) update_bes_dens_spec_window
;      --> to update the fields information on bes_dens_spec_window
;
;  16) bes_dens_spec_window_event
;      --> to control events generated by bes_dens_spec_window
;
;  17) update_bes_dens_coh_window
;      --> to update the fields information on bes_dens_coh_window
;
;  18) bes_dens_coh_window_event
;      --> to control events generated by bes_dens_coh_window
;
;  19) update_bes_dens_temporal_corr_window
;      --> to update the fields information on bes_dens_temporal_corr_window
;
;  20) bes_dens_temporal_corr_window_event
;      --> to control events generated by bes_dens_temporal_corr_window
;
;  21) update_bes_dens_spa_temp_corr_window
;      --> to update the fields information on bes_dens_spa_temp_corr_window
;
;  22) sens_check_bes_dens_spa_temp_corr_window
;      --> to control the sensitivity of the widgets
;
;  23) bes_dens_spa_temp_corr_window_event
;      --> to control events generated by bes_dens_spa_temp_corr_window
;
;  24) update_bes_dens_spa_spa_corr_window_event
;      --> to update the field information on bes_dens_spa_spa_corr_window
;
;  25) bes_dens_spa_spa_corr_window_event
;      --> co control events generated by bes_dens_spa_spa_corr_window
;
;  26) update_bes_vel_evol_window
;      --> to update the fields information on bes_vel_evol_window
;
;  27) bes_vel_evol_window_event
;      --> to control events generated by bes_vel_evol_window
;
;  28) update_bes_vel_spec_window
;      --> to update the fields information on bes_vel_spec_window
;
;  29) bes_vel_spec_window_event
;      --> to control events generated by bes_vel_spec_window
;
;  30) update_show_flux_surface_window
;      --> to update the fields information on show_flux_surface_window
;
;  31) show_flux_surface_window_event
;      --> to control events generated by show_flux_surface_window
;
;  33) bes_analyser_event
;     --> to contol events generated by the main window (bes_analyser)
;
;===================================================================================

@bes_analyser_cuda_ctrl
@bes_analyser_read_data
@bes_analyser_plot_ctrl
@bes_analyser_stat_anal
@bes_analyser_result_data_ctrl



;===================================================================================
; This function controls events generated by bes_analyser_err_msg_window
;===================================================================================
; The function parameters:
;   1) 'event' is generated by the system and passed to the procedure 
;        for control purpose
;===================================================================================
pro bes_analyser_err_msg_window_event, event

  widget_control, event.top, get_uvalue = ok_button

  if event.id eq ok_button then $
    widget_control, event.top, /destroy

end


;===================================================================================
; This function controls events generated by IDL_msg_box
;===================================================================================
; The function parameters:
;   1) 'event' is generated by the system and passed to the procedure 
;        for control purpose
;===================================================================================
pro IDL_msg_box_window_event, event

; get the user value
  widget_control, event.top, get_uvalue = id_main_base

; from id_main_base, get the info
  widget_control, id_main_base, get_uvalue = info

; check if called due to kill event
  if( (tag_names(event, /structure_name) eq 'WIDGET_KILL_REQUEST') or $ 
      (event.id eq info.id.IDL_msg_box_window.close_button) ) then begin
    kill_IDL_msg_box_window, info

  ; change the text on show_hide_IDL_msg_box_button
    widget_control, info.id.main_window.show_hide_IDL_msg_box_button, set_value = 'SHOW the IDL Message Box'
    info.main_window_data.IDL_msg_box_window_ON = 0

  ;save the info back to main_base
    widget_control, id_main_base, set_uvalue = info

    return
  endif

end

;===================================================================================
; This function controls events generated by CDUA_comm_window
;===================================================================================
; The function parameters:
;   1) 'event' is generated by the system and passed to the procedure 
;        for control purpose
;===================================================================================
pro CUDA_comm_window_event, event

; get the user value
  widget_control, event.top, get_uvalue = id_main_base

; from id_main_base, get the info
  widget_control, id_main_base, get_uvalue = info

; get the IDs of CUDA_comm_window
  id = info.id.CUDA_comm_window

; check if called due to kill event
  if( (tag_names(event, /structure_name) eq 'WIDGET_KILL_REQUEST') or $ 
      (event.id eq id.close_button) ) then begin

    kill_CUDA_comm_window, info
    return
  endif

; called due to open_comm_button
  if event.id eq id.open_comm_button then begin
  ; before opening the CUDA line, check whether the platform has capability to run CUDA.
    spawn, 'nvcc --version', out, errmsg
    if errmsg ne '' then begin
      err_num = 100
      err_msg = bes_analyser_error_list(err_num)
      create_err_msg_window, err_msg, id.CUDA_comm_window_base
      return
    endif

  ;open the CUDA communication line if it is not opend, yet.
    if info.CUDA_comm_window_data.comm_line_on eq 0 then begin
      str_err_msg = open_cuda_comm_line(info)
      if str_err_msg ne '' then $
        create_err_msg_window, str_err_msg, info.id.CUDA_comm_window.CUDA_comm_window_base $
      else $
        info.CUDA_comm_window_data.comm_line_on = 1
    endif
    widget_control, info.id.main_window.main_base, set_uvalue = info
    return
  endif


; called due to close_comm_button
  if event.id eq id.close_comm_button then begin
  ;close the CUDA communication line, if it is opened.
    if info.CUDA_comm_window_data.comm_line_on eq 1 then begin
      close_cuda_comm_line, info
      info.CUDA_comm_window_data.comm_line_on = 0
    endif
    widget_control, info.id.main_window.main_base, set_uvalue = info
    return
  endif

end

;===================================================================================
; This function updates the info field for time_sel_window
;===================================================================================
; The function parameters:
;   1) 'info' is a structure that is saved as uvalue under the main_base.
;===================================================================================
pro update_time_sel_window, info
; retrieve the time_sel_window IDs
  id = info.id.time_sel_window

; get frequency filtering range
  widget_control, id.freq_filter_low_text, get_value = str1
  str1 = str1[0]
    widget_control, id.freq_filter_high_text, get_value = str2
  str2 = str2[0]

  if is_valid_str_to_be_number(str1) ne 1 then begin
    error_num = 6
    str_msg = bes_analyser_error_list(error_num)
    create_err_msg_window, str_msg, id.time_sel_window_base
    str1 = '0.0'
    widget_control, id.freq_filter_low_text, set_value = str1
  endif

  if is_valid_str_to_be_number(str2) ne 1 then begin
    error_num = 7
    str_msg = bes_analyser_error_list(error_num)
    create_err_msg_window, str_msg, id.time_sel_window_base
    str2 = '50.0'
    widget_control, id.freq_filter_high_text, set_value = str2
  endif

  info.time_sel_window_data.freq_filter_low = float(str1)
  info.time_sel_window_data.freq_filter_high = float(str2)

  for i = 0, 31 do $
    info.time_sel_window_data.BES_ch_sel[i] = widget_info(id.BES_Ch_button[i], /button_set)

  for i = 0, 7 do $
    info.time_sel_window_data.BES_RAD_ch_sel[i] = widget_info(id.RAD_Ch_button[i], /button_set)

  for i = 0, 3 do $
    info.time_sel_window_data.BES_POL_ch_sel[i] = widget_info(id.POL_Ch_button[i], /button_set)
  
  info.time_sel_window_data.plasma_current_sel = widget_info(id.plasma_current_button, /button_set)
  widget_control, id.plasma_current_scale_text, get_value = str
  str = str[0]
  if is_valid_str_to_be_number(str) ne 1 then begin
    error_num = 8
    str_msg = bes_analyser_error_list(error_num)
    create_err_msg_window, str_msg, id.time_sel_window_base
    str = '1.0'
    widget_control, id.plasma_current_scale_text, set_value = str
  endif
  info.time_sel_window_data.plasma_current_scale = float(str)

  info.time_sel_window_data.plasma_density_sel = widget_info(id.plasma_density_button, /button_set)
  widget_control, id.plasma_density_scale_text, get_value = str
  str = str[0]
   if is_valid_str_to_be_number(str) ne 1 then begin
    error_num = 9
    str_msg = bes_analyser_error_list(error_num)
    create_err_msg_window, str_msg, id.time_sel_window_base
    str = '1.0e+20'
    widget_control, id.plasma_density_scale_text, set_value = str
  endif
  info.time_sel_window_data.plasma_density_scale = float(str) 

  info.time_sel_window_data.SS_beam_sel = widget_info(id.SS_beam_button, /button_set)
  widget_control, id.SS_beam_scale_text, get_value = str
  str = str[0]
   if is_valid_str_to_be_number(str) ne 1 then begin
    error_num = 10
    str_msg = bes_analyser_error_list(error_num)
    create_err_msg_window, str_msg, id.time_sel_window_base
    str = '1.0'
    widget_control, id.SS_beam_scale_text, set_value = str
  endif
  info.time_sel_window_data.SS_beam_scale = float(str)

  info.time_sel_window_data.dalpha_sel = widget_info(id.dalpha_button, /button_set)
  widget_control, id.dalpha_scale_text, get_value = str
  str = str[0]
   if is_valid_str_to_be_number(str) ne 1 then begin
    error_num = 11
    str_msg = bes_analyser_error_list(error_num)
    create_err_msg_window, str_msg, id.time_sel_window_base
    str = '1.0e+19'
    widget_control, id.dalpha_scale_text, set_value = str
  endif
  info.time_sel_window_data.dalpha_scale = float(str)

  widget_control, info.id.main_window.main_base, set_uvalue = info

end


;===================================================================================
; This function controls events generated by time_sel_window
;===================================================================================
; The function parameters:
;   1) 'event' is generated by the system and passed to the procedure 
;        for control purpose
;===================================================================================
pro time_sel_window_event, event

; get the user value
  widget_control, event.top, get_uvalue = id_main_base

; from id_main_base, get the info
  widget_control, id_main_base, get_uvalue = info

; get the IDs of time_sel_window
  id = info.id.time_sel_window

; check if called due to kill_event
  if ( (tag_names(event, /structure_name) eq 'WIDGET_KILL_REQUEST') or $ 
       (event.id eq id.close_button) ) then begin
    update_time_sel_window, info
    kill_time_sel_window, info
    return
  endif 

; called due to BES_Ch_button
  for i = 0, 31 do begin
    if event.id eq id.BES_Ch_button[i] then begin
      button_set = widget_info(id.BES_Ch_button[i], /button_set)
      RAD_pos = i mod 8
      POL_pos = i/8
      bes_ch_button_ctrl, RAD_pos, POL_pos, button_set, $
                          id.BES_Ch_button, id.POL_Ch_button, id.RAD_Ch_button
      return
    endif
  endfor

; called due to POL_Ch_button
  for i = 0, 3 do begin
    if event.id eq id.POL_Ch_button[i] then begin
      button_set = widget_info(id.POL_Ch_button[i], /button_set)
      bes_pol_ch_button_ctrl, i, button_set, $
                              id.BES_Ch_button, id.POL_Ch_button, id.RAD_Ch_button
      return
    endif
  endfor

; called due to RAD_Ch_button
  for i = 0, 7 do begin
    if event.id eq id.RAD_Ch_button[i] then begin
      button_set = widget_info(id.RAD_Ch_button[i], /button_set)
      bes_rad_ch_button_ctrl, i, button_set, $
                              id.BES_Ch_button, id.POL_Ch_button, id.RAD_Ch_button
      return
    endif
  endfor


; called due to plot_button
  if event.id eq id.plot_button then begin
    update_time_sel_window, info

    widget_control, /hourglass
    widget_control, id.plot_button, sensitive = 0
    load_result = load_data_for_time_sel_win(info)
    widget_control, id.plot_button, sensitive = 1

    if load_result.erc eq 0 then begin
    ; no error occured.  plot the data.
      result = plot_time_sel_window(info)	; plot the data on the time_sel_window
      if result.erc ne 0 then begin
        create_err_msg_window, result.errmsg, id.time_sel_window_base
      endif
    endif else if load_result.erc eq 1 then begin
    ; error occured.  but not fatal errors.
    ; show a warning message, then plot the data.
      create_err_msg_window, load_result.errmsg, id.time_sel_window_base
      result = plot_time_sel_window(info)	; plot the data on the time_sel_window
      if result.erc ne 0 then begin
        create_err_msg_window, result.errmsg, id.time_sel_window_base
      endif
    endif else begin
    ; fatal error occured.
    ; plot cannot be performed.
      create_err_msg_window, load_result.errmsg, id.time_sel_window_base
      return
    endelse

    return
  endif

; called due to save_button
;  save the time file
  if ( (event.id eq id.save_button) or (event.id eq id.filename_text) ) then begin
  ; check if time-selected-regions exist.
    if( info.time_sel_struct.curr_num_time_regions lt 1 ) then begin
      err_num = 14
      errmsg = bes_analyser_error_list(err_num)
      create_err_msg_window, errmsg, id.time_sel_window_base
      return
    endif

  ; check the bes_analyser_time folder exists.
    dir_name = 'bes_analyser_time/'
    spawn, 'ls -d1 */', out_dir_name, outerr, count = num_dir
    if num_dir lt 1 then begin
    ; bes_analyser_time folder does not exist
      linux_command = 'mkdir ' + dir_name
      spawn, linux_command
    endif else begin
      inx = where(out_dir_name eq dir_name, count)
      if count eq 0 then begin
      ; bes_analyser_time folder does not exist
        linux_command = 'mkdir ' + dir_name
        spawn, linux_command
      endif
    endelse

  ; now, get the filename from the filename_text box
    widget_control, id.filename_text, get_value = str
    new_time_filename = str[0] + '.time'

  ; check if new_time_filename is empty string
    if new_time_filename eq '.time' then begin
      err_num = 12
      errmsg = bes_analyser_error_list(err_num)
      create_err_msg_window, errmsg, id.time_sel_window_base
      return
    endif

  ; get the existing files (files only)
    linux_command = 'ls ' + dir_name + ' | grep -F .time'
    spawn, linux_command, out_filename, outerr, count = num_file

  ; check whether the same filename exist or not
    inx = where(new_time_filename eq out_filename, count)
    if count ne 0 then begin
      err_num = 13
      errmsg = bes_analyser_error_list(err_num)
      create_err_msg_window, errmsg, id.time_sel_window_base
      return
    endif

  ; now, save the time file
    if info.main_window_data.IDL_msg_box_window_ON eq 1 then begin
      widget_control, info.id.IDL_msg_box_window.msg_text, set_value = '', /append
      str = 'Time regions to be saved are (total ' + $
            string(info.time_sel_struct.curr_num_time_regions, format='(i0)') + '): '
      widget_control, info.id.IDL_msg_box_window.msg_text, set_value = str, /append
      for i = 0, info.time_sel_struct.curr_num_time_regions - 1 do begin
        str = '  ' + string(i+1, format='(i2)') + ': [' + $
                     string(info.time_sel_struct.time_regions[i, 0], format = '(f+0.0)') + $
                     string(9b) + $	;horizontal tab
                     string(info.time_sel_struct.time_regions[i, 1], format = '(f+0.0)') + ']'
        widget_control, info.id.IDL_msg_box_window.msg_text, set_value = str, /append
      endfor
    endif

    save_time_file, info.time_sel_struct, new_time_filename, dir_name

    if info.main_window_data.IDL_msg_box_window_ON eq 1 then begin
      str = '  ' + new_time_filename + ' is saved!'
      widget_control, info.id.IDL_msg_box_window.msg_text, set_value = str, /append
    endif

    return
  endif

; called due to load_button
;  load the existing time file
  if event.id eq id.load_button then begin
  ; check if time_sel_plot is empty or not.
    widget_control, info.id.main_window.time_sel_draw, get_uvalue = plotdata
    if plotdata.curr_num_plots lt 1 then begin
      err_num = 15
      errmsg = bes_analyser_error_list(err_num)
      create_err_msg_window, errmsg, id.time_sel_window_base
      return
    endif

  ; Get the existing files from the 'bes_analyser_time/' directory
    dir_name = 'bes_analyser_time/'
    linux_command = 'ls ' + dir_name + ' | grep -F .time'
    spawn, linux_command, out_filename, outerr, count = num_file
    if num_file eq 0 then begin
    ; no existing files
      err_num = 16
      errmsg = bes_analyser_error_list(err_num)
      create_err_msg_window, errmsg, id.time_sel_window_base
      return
    endif

  ; Create and show a modal based window
    create_time_file_sel_window, id_main_base, id.time_sel_window_base, out_filename

  ; info structure may have been updated by time_file_sel_window if a user selected time file.
  ; thus, reload the info structure
    widget_control, id_main_base, get_uvalue = info

  ; get the filename to be loaded
    fname = info.time_sel_window_data.loaded_time_file

  ; reset the info.time_sel_window_data.loaded_time_file
    info.time_sel_window_data.loaded_time_file = ''
    widget_control, id_main_base, set_uvalue = info

  ; if fname is not empty, then load the time regions
    if fname ne '' then begin
    ; check the validity of fname
      if is_vaild_time_file(fname) ne 1 then begin
        err_num = 18
        errmsg = bes_analyser_error_list(err_num)
        create_err_msg_window, errmsg, id.time_sel_window_base
        return
      endif

      if info.main_window_data.IDL_msg_box_window_ON eq 1 then begin
        widget_control, info.id.IDL_msg_box_window.msg_text, set_value = '', /append
        str = 'Loading the time file: [' + dir_name + fname + ']...'
        widget_control, info.id.IDL_msg_box_window.msg_text, set_value = str, /append, /no_newline
      endif

      load_result = load_time_file(fname, dir_name)

      if load_result.erc ne 0 then begin
        if info.main_window_data.IDL_msg_box_window_ON eq 1 then begin
          widget_control, info.id.IDL_msg_box_window.msg_text, set_value = 'FAILED!', /append
        endif
      ; failed to read the time file
        err_num = 17
        errmsg = bes_analyser_error_list(err_num)
        create_err_msg_window, errmsg, id.time_sel_window_base
        return
      endif

      if info.main_window_data.IDL_msg_box_window_ON eq 1 then begin
        widget_control, info.id.IDL_msg_box_window.msg_text, set_value = 'DONE!', /append
        str = 'Loaded time regions are (total ' + $
              string(load_result.num_time_regions, format='(i0)') + '): '
        widget_control, info.id.IDL_msg_box_window.msg_text, set_value = str, /append
        for i = 0, load_result.num_time_regions - 1 do begin
          str = '  ' + string(i+1, format='(i2)') + ': [' + $
                       string(load_result.time_regions[i, 0], format = '(f+0.0)') + $
                       string(9b) + $	;horizontal tab
                       string(load_result.time_regions[i, 1], format = '(f+0.0)') + ']'
          widget_control, info.id.IDL_msg_box_window.msg_text, set_value = str, /append
        endfor
      endif

    ;update info.time_sel_struct and save it
      info.time_sel_struct.curr_num_time_regions = load_result.num_time_regions
      info.time_sel_struct.time_regions[*, *] = 0.0
      for i = 0, load_result.num_time_regions - 1 do begin
        info.time_sel_struct.time_regions[i, *] = load_result.time_regions[i, *]
      endfor
      widget_control, id_main_base, set_uvalue = info

    ;replot the time_sel_window
      result = plot_time_sel_window(info)	; plot the data on the time_sel_window
      if result.erc ne 0 then begin
        create_err_msg_window, result.errmsg, id.time_sel_window_base
      endif

    endif

    return
  endif

end


;===================================================================================
; This procedure controls events generated by time_file_sel_window
;===================================================================================
; The function parameters:
;   1) 'event' is generated by the system and passed to the procedure 
;        for control purpose
;===================================================================================
pro time_file_sel_window_event, event

; get the user value
  widget_control, event.top, get_uvalue = idinfo

; check if called due to kill_event
  if ( (tag_names(event, /structure_name) eq 'WIDGET_KILL_REQUEST') or $ 
       (event.id eq idinfo.cancel_button) ) then begin
    kill_time_file_sel_window, idinfo.base
  endif

; called due to load_button
  if event.id eq idinfo.load_button then begin
  ; get the selected filename
    fname = widget_info(idinfo.time_file_combo, /combobox_gettext)
  
  ; save the filename to info
    widget_control, idinfo.id_main_base, get_uvalue = info
    info.time_sel_window_data.loaded_time_file = fname
    widget_control, idinfo.id_main_base, set_uvalue = info

  ; kill the window
    kill_time_file_sel_window, idinfo.base
  endif

end


;===================================================================================
; This procedure controls events generated by save_options_window
;===================================================================================
; The function parameters:
;   1) 'event' is generated by the system and passed to the procedure 
;        for control purpose
;===================================================================================
pro save_options_window_event, event

; get the user value
  widget_control, event.top, get_uvalue = idinfo

; check if called due to kill_event
  if ( (tag_names(event, /structure_name) eq 'WIDGET_KILL_REQUEST') or $ 
       (event.id eq idinfo.cancel_button) ) then begin

    kill_save_options_window, idinfo.base

    return
  endif

; called due to save button
  if event.id eq idinfo.save_button then begin
  ; get the filename and comments
    widget_control, idinfo.filename_text, get_value = filename
    filename = filename[0]
    widget_control, idinfo.comment_text, get_value = comment

  ; save the option
    result = save_options_info(idinfo.id_main_base, filename, idinfo.file_extension, comment) 

  ; check the result
    if result ne 0 then begin
      error_num = result
      str_msg = bes_analyser_error_list(error_num)
      create_err_msg_window, str_msg, idinfo.base
    endif else begin
      kill_save_options_window, idinfo.base
    endelse

    return

  endif

end


;===================================================================================
; This procedure controls events generated by load_options_window
;===================================================================================
; The function parameters:
;   1) 'event' is generated by the system and passed to the procedure 
;        for control purpose
;===================================================================================
pro load_options_window_event, event


end


;===================================================================================
; This function updates the info field for bes_time_evol_window
;===================================================================================
; The function parameters:
;   1) 'idinfo' is a structure that is saved as uvalue under bes_time_evol_window
;===================================================================================
pro update_bes_time_evol_window, idinfo

; get the info structure
  widget_control, idinfo.id_main_base, get_uvalue = info

; get frequency filtering range
  widget_control, idinfo.freq_filter_low_text, get_value = str1
  str1 = str1[0]
  widget_control, idinfo.freq_filter_high_text, get_value = str2
  str2 = str2[0]

  if is_valid_str_to_be_number(str1) ne 1 then begin
    error_num = 6
    str_msg = bes_analyser_error_list(error_num)
    create_err_msg_window, str_msg, idinfo.base
    str1 = '0.0'
    widget_control, idinfo.freq_filter_low_text, set_value = str1
  endif

  if is_valid_str_to_be_number(str2) ne 1 then begin
    error_num = 7
    str_msg = bes_analyser_error_list(error_num)
    create_err_msg_window, str_msg, idinfo.base
    str2 = '50.0'
    widget_control, idinfo.freq_filter_high_text, set_value = str2
  endif

  info.bes_time_evol_window_data.freq_filter_low = float(str1)
  info.bes_time_evol_window_data.freq_filter_high = float(str2)

; get selected BES channels
  for i = 0, 31 do $
    info.bes_time_evol_window_data.BES_ch_sel[i] = widget_info(idinfo.BES_Ch_button[i], /button_set)

  for i = 0, 7 do $
    info.bes_time_evol_window_data.BES_RAD_ch_sel[i] = widget_info(idinfo.RAD_Ch_button[i], /button_set)

  for i = 0, 3 do $
    info.bes_time_evol_window_data.BES_POL_ch_sel[i] = widget_info(idinfo.POL_Ch_button[i], /button_set)

; save info
  widget_control, idinfo.id_main_base, set_uvalue = info

end


;===================================================================================
; This procedure controls events generated by bes_time_evol_window
;===================================================================================
; The function parameters:
;   1) 'event' is generated by the system and passed to the procedure 
;        for control purpose
;===================================================================================
pro bes_time_evol_window_event, event

; get the user value
  widget_control, event.top, get_uvalue = idinfo

; check if called due to kill_event
  if ( (tag_names(event, /structure_name) eq 'WIDGET_KILL_REQUEST') or $ 
       (event.id eq idinfo.close_button) ) then begin
  ; update the fields
    update_bes_time_evol_window, idinfo

  ; re-enable the ACTION buttons
    widget_control, idinfo.id_main_base, get_uvalue = info

    widget_control, info.id.main_window.basic_anal_action_button, sensitive = 1
    widget_control, info.id.main_window.dens_advanced_anal_action_button, sensitive = 1
    widget_control, info.id.main_window.vel_advanced_anal_action_button, sensitive = 1

  ; kill the window
    kill_bes_time_evol_window, idinfo.base
    return
  endif

; called due to BES_Ch_button
  for i = 0, 31 do begin
    if event.id eq idinfo.BES_Ch_button[i] then begin
      button_set = widget_info(idinfo.BES_Ch_button[i], /button_set)
      RAD_pos = i mod 8
      POL_pos = i/8
      bes_ch_button_ctrl, RAD_pos, POL_pos, button_set, $
                          idinfo.BES_Ch_button, idinfo.POL_Ch_button, idinfo.RAD_Ch_button
      return
    endif
  endfor

; called due to POL_Ch_button
  for i = 0, 3 do begin
    if event.id eq idinfo.POL_Ch_button[i] then begin
      button_set = widget_info(idinfo.POL_Ch_button[i], /button_set)
      bes_pol_ch_button_ctrl, i, button_set, $
                              idinfo.BES_Ch_button, idinfo.POL_Ch_button, idinfo.RAD_Ch_button
      return
    endif
  endfor

; called due to RAD_Ch_button
  for i = 0, 7 do begin
    if event.id eq idinfo.RAD_Ch_button[i] then begin
      button_set = widget_info(idinfo.RAD_Ch_button[i], /button_set)
      bes_rad_ch_button_ctrl, i, button_set, $
                              idinfo.BES_Ch_button, idinfo.POL_Ch_button, idinfo.RAD_Ch_button
      return
    endif
  endfor


; called due to either plot button or oplot button
  if ( (event.id eq idinfo.plot_button) or (event.id eq idinfo.oplot_button) ) then begin
  ; show hour glass
    widget_control, /hourglass

  ; disable the buttons
    widget_control, idinfo.plot_button, sensitive = 0
    widget_control, idinfo.oplot_button, sensitive = 0
    widget_control, idinfo.save_options_button, sensitive = 0
    widget_control, idinfo.load_options_button, sensitive = 0
    widget_control, idinfo.close_button, sensitive = 0

  ; update the fields
    update_bes_time_evol_window, idinfo

  ; plot the data
    if event.id eq idinfo.plot_button then $
      result = ctrl_plot_raw_bes_data(idinfo) $
    else $
      result = ctrl_plot_raw_bes_data(idinfo, /overplot)

    if result.erc ne 0 then begin
      create_err_msg_window, result.errmsg, idinfo.base
    endif

  ; enable the buttons
    widget_control, idinfo.plot_button, sensitive = 1
    widget_control, idinfo.oplot_button, sensitive = 1
    widget_control, idinfo.save_options_button, sensitive = 1
    widget_control, idinfo.load_options_button, sensitive = 1
    widget_control, idinfo.close_button, sensitive = 1

    return
  endif

; called due to load_options_button
  if event.id eq idinfo.load_options_button then begin
  ; set the file extension
    file_extension = '.bes_evol'
  ; get the filename
    filename = create_load_options_window(idinfo.id_main_base, file_extension)
  ; load the options
    if filename ne '' then begin
      result = load_options_info(idinfo.id_main_base, idinfo, filename, file_extension)
      if result ne 0 then begin
        errmsg = bes_analyser_error_list(result)
        create_err_msg_window, errmsg, idinfo.base
      endif
    endif

    return
  endif

; called due to save_options_button
  if event.id eq idinfo.save_options_button then begin
  ; set the file extension
    file_extension = '.bes_evol'
  ; update the fields
    update_bes_time_evol_window, idinfo
  ; create the window
    create_save_options_window, idinfo.id_main_base, file_extension

    return
  endif



end


;===================================================================================
; This function updates the info field for bes_rms_dc_time_evol_window
;===================================================================================
; The function parameters:
;   1) 'idinfo' is a structure that is saved as uvalue under bes_rms_dc_time_evol_window
;===================================================================================
pro update_rms_dc_time_evol_window, idinfo

; get the info structure
  widget_control, idinfo.id_main_base, get_uvalue = info

  dt = info.main_window_data.BES_data.dt
; get number of points for averaging
  widget_control, idinfo.avg_nt_text, get_value = str
  str = str[0]
  if is_valid_str_to_be_number(str) ne 1 then begin
    err_num = 202
    str_msg = bes_analyser_error_list(err_num)
    create_err_msg_window, str_msg, idinfo.base	
    str = '1000'
    widget_control, idinfo.avg_nt_text, set_value = str
  endif
  temp_avg_nt = long(str)
  if temp_avg_nt lt 2 then begin
    err_num = 203
    str_msg = bes_analyser_error_list(err_num)
    create_err_msg_window, str_msg, idinfo.base
    str = '1000'
    widget_control, idinfo.avg_nt_text, set_value = str
  endif
  avg_nt = long(str)
  time_resolution = dt * avg_nt * 1e6	;in [micro sec]
  str = ' dt of outupt = ' + string(time_resolution, format='(f0.2)') + ' [micro-sec]'
  widget_control, idinfo.time_res_label, set_value = str

  info.rms_dc_time_evol_window_data.avg_nt = avg_nt

; get use_LPF_for_DC
  info.rms_dc_time_evol_window_data.use_LPF_for_DC = widget_info(idinfo.use_LPF_for_DC_button, /button_set)

; get DC_freq_filter_high
  widget_control, idinfo.DC_freq_filter_high_text, get_value = str
  str = str[0]
  if is_valid_str_to_be_number(str) ne 1 then begin
    error_num = 204
    str_msg = bes_analyser_error_list(error_num)
    create_err_msg_window, str_msg, idinfo.base
    str = '10.0'
    widget_control, idinfo.DC_freq_filter_high_text, set_value = str
  endif
  info.rms_dc_time_evol_window_data.DC_freq_filter_high = float(str)

; get RMS_frequency range
  widget_control, idinfo.RMS_freq_filter_low_text, get_value = str1
  str1 = str1[0]
  widget_control, idinfo.RMS_freq_filter_high_text, get_value = str2
  str2 = str2[0]

  if is_valid_str_to_be_number(str1) ne 1 then begin
    error_num = 205
    str_msg = bes_analyser_error_list(error_num)
    create_err_msg_window, str_msg, idinfo.base
    str1 = '0.0'
    widget_control, idinfo.RMS_freq_filter_low_text, set_value = str1
  endif

  if is_valid_str_to_be_number(str2) ne 1 then begin
    error_num = 206
    str_msg = bes_analyser_error_list(error_num)
    create_err_msg_window, str_msg, idinfo.base
    str2 = '200.0'
    widget_control, idinfo.RMS_freq_filter_high_text, set_value = str2
  endif

  info.rms_dc_time_evol_window_data.RMS_freq_filter_low = float(str1)
  info.rms_dc_time_evol_window_data.RMS_freq_filter_high = float(str2)

; get subtract_DC
  info.rms_dc_time_evol_window_data.subtract_DC = widget_info(idinfo.subtract_DC_button, /button_set)

; get selected BES channels
  for i = 0, 31 do $
    info.rms_dc_time_evol_window_data.BES_ch_sel[i] = widget_info(idinfo.BES_Ch_button[i], /button_set)

  for i = 0, 7 do $
    info.rms_dc_time_evol_window_data.BES_RAD_ch_sel[i] = widget_info(idinfo.RAD_Ch_button[i], /button_set)

  for i = 0, 3 do $
    info.rms_dc_time_evol_window_data.BES_POL_ch_sel[i] = widget_info(idinfo.POL_Ch_button[i], /button_set)

; save info
  widget_control, idinfo.id_main_base, set_uvalue = info

end


;===================================================================================
; This procedure controls events generated by bes_rms_dc_time_evol_window
;===================================================================================
; The function parameters:
;   1) 'event' is generated by the system and passed to the procedure 
;        for control purpose
;===================================================================================
pro bes_rms_dc_time_evol_window_event, event

; get the user value
  widget_control, event.top, get_uvalue = idinfo

; check if called due to kill_event
  if ( (tag_names(event, /structure_name) eq 'WIDGET_KILL_REQUEST') or $ 
       (event.id eq idinfo.close_button) ) then begin
  ; update the fields
    update_rms_dc_time_evol_window, idinfo

  ; re-enable the ACTION buttons
    widget_control, idinfo.id_main_base, get_uvalue = info

    widget_control, info.id.main_window.basic_anal_action_button, sensitive = 1
    widget_control, info.id.main_window.dens_advanced_anal_action_button, sensitive = 1
    widget_control, info.id.main_window.vel_advanced_anal_action_button, sensitive = 1

  ; kill the window
    kill_bes_rms_dc_time_evol_window, idinfo.base
    return
  endif

; called due to help_button
  if event.id eq idinfo.help_button then begin
    filename = 'BES_Analyser_RMS_DC_Explain.pdf'
    help_result = open_help_file(filename)
    if help_result.erc ne 0 then begin
      create_err_msg_window, help_result.errmsg, idinfo.base
    endif
    return
  endif

; called due to BES_Ch_button
  for i = 0, 31 do begin
    if event.id eq idinfo.BES_Ch_button[i] then begin
      button_set = widget_info(idinfo.BES_Ch_button[i], /button_set)
      RAD_pos = i mod 8
      POL_pos = i/8
      bes_ch_button_ctrl, RAD_pos, POL_pos, button_set, $
                          idinfo.BES_Ch_button, idinfo.POL_Ch_button, idinfo.RAD_Ch_button
      return
    endif
  endfor

; called due to POL_Ch_button
  for i = 0, 3 do begin
    if event.id eq idinfo.POL_Ch_button[i] then begin
      button_set = widget_info(idinfo.POL_Ch_button[i], /button_set)
      bes_pol_ch_button_ctrl, i, button_set, $
                              idinfo.BES_Ch_button, idinfo.POL_Ch_button, idinfo.RAD_Ch_button
      return
    endif
  endfor

; called due to RAD_Ch_button
  for i = 0, 7 do begin
    if event.id eq idinfo.RAD_Ch_button[i] then begin
      button_set = widget_info(idinfo.RAD_Ch_button[i], /button_set)
      bes_rad_ch_button_ctrl, i, button_set, $
                              idinfo.BES_Ch_button, idinfo.POL_Ch_button, idinfo.RAD_Ch_button
      return
    endif
  endfor

; called due to use_LPF_for_DC_button
  if event.id eq idinfo.use_LPF_for_DC_button then begin
    widget_control, idinfo.DC_freq_filter_high_text, sensitive = widget_info(idinfo.use_LPF_for_DC_button, /button_set)

    return
  endif

; called due to plot_button or oplot button
  if (event.id eq idinfo.plot_button) or (event.id eq idinfo.oplot_button) then begin
  ; show hour glass
    widget_control, /hourglass

  ; disable the buttons
    widget_control, idinfo.plot_button, sensitive = 0
    widget_control, idinfo.oplot_button, sensitive = 0
    widget_control, idinfo.save_options_button, sensitive = 0
    widget_control, idinfo.load_options_button, sensitive = 0
    widget_control, idinfo.close_button, sensitive = 0

  ; update the fields
    update_rms_dc_time_evol_window, idinfo

  ; plot the data
    if event.id eq idinfo.plot_button then $
      result = ctrl_plot_rms_dc_bes_data(idinfo) $
    else $
      result = ctrl_plot_rms_dc_bes_data(idinfo, /overplot)

    if result.erc ne 0 then begin
      create_err_msg_window, result.errmsg, idinfo.base
    endif

  ; enable the buttons
    widget_control, idinfo.plot_button, sensitive = 1
    widget_control, idinfo.oplot_button, sensitive = 1
    widget_control, idinfo.save_options_button, sensitive = 1
    widget_control, idinfo.load_options_button, sensitive = 1
    widget_control, idinfo.close_button, sensitive = 1

    return
  endif

; called due to load_options_button
  if event.id eq idinfo.load_options_button then begin
  ; set the file extension
    file_extension = '.rms_evol'
  ; get the filename
    filename = create_load_options_window(idinfo.id_main_base, file_extension)
  ; load the options
    if filename ne '' then begin
      result = load_options_info(idinfo.id_main_base, idinfo, filename, file_extension)
      if result ne 0 then begin
        errmsg = bes_analyser_error_list(result)
        create_err_msg_window, errmsg, idinfo.base
      endif
    endif

    return
  endif

; called due to save_options_button
  if event.id eq idinfo.save_options_button then begin
  ; set the file extension
    file_extension = '.rms_evol'
  ; update the fields
    update_rms_dc_time_evol_window, idinfo
  ; create the window
    create_save_options_window, idinfo.id_main_base, file_extension

    return
  endif

end


;===================================================================================
; This procedure updates the info field for bes_animation_window
;===================================================================================
; The function parameters:
;   1) 'idinfo' is a structure that is saved as uvalue under bes_animation_window
;===================================================================================
pro update_bes_animation_window, idinfo

; get the info structure
  widget_control, idinfo.id_main_base, get_uvalue = info

; get the factor to increase the spatial resolution
  widget_control, idinfo.factor_inc_spa_pts_text, get_value = str
  str = str[0]
  if is_valid_str_to_be_number(str) ne 1 then begin
    err_num = 250
    str_msg = bes_analyser_error_list(err_num)
    create_err_msg_window, str_msg, idinfo.base	
    str = '10'
    widget_control, idinfo.factor_inc_spa_pts_text, set_value = str
  endif
  temp_factor_inc_spa_pts = fix(str)
  if ( (temp_factor_inc_spa_pts lt 1) or (temp_factor_inc_spa_pts gt 30) ) then begin
    err_num = 251
    str_msg = bes_analyser_error_list(err_num)
    create_err_msg_window, str_msg, idinfo.base	
    str = '10'
    widget_control, idinfo.factor_inc_spa_pts_text, set_value = str
  endif
  info.bes_animation_window_data.factor_inc_spa_pts = fix(str)

; get frequency range
  widget_control, idinfo.freq_filter_low_text, get_value = str1
  str1 = str1[0]
  widget_control, idinfo.freq_filter_high_text, get_value = str2
  str2 = str2[0]
  if is_valid_str_to_be_number(str1) ne 1 then begin
    error_num = 252
    str_msg = bes_analyser_error_list(error_num)
    create_err_msg_window, str_msg, idinfo.base
    str1 = '0.0'
    widget_control, idinfo.freq_filter_low_text, set_value = str1
  endif
  if is_valid_str_to_be_number(str2) ne 1 then begin
    error_num = 253
    str_msg = bes_analyser_error_list(error_num)
    create_err_msg_window, str_msg, idinfo.base
    str2 = '200.0'
    widget_control, idinfo.freq_filter_high_text, set_value = str2
  endif
  info.bes_animation_window_data.freq_filter_low = float(str1)
  info.bes_animation_window_data.freq_filter_high = float(str2)

; get number of points for averaging
  widget_control, idinfo.avg_nt_text, get_value = str
  str = str[0]
  if is_valid_str_to_be_number(str) ne 1 then begin
    err_num = 254
    str_msg = bes_analyser_error_list(err_num)
    create_err_msg_window, str_msg, idinfo.base	
    str = '1000'
    widget_control, idinfo.avg_nt_text, set_value = str
  endif
  temp_avg_nt = long(str)
  if temp_avg_nt lt 2 then begin
    err_num = 255
    str_msg = bes_analyser_error_list(err_num)
    create_err_msg_window, str_msg, idinfo.base
    str = '1000'
    widget_control, idinfo.avg_nt_text, set_value = str
  endif
  info.bes_animation_window_data.avg_nt = long(str)

; get DC_freq_filter_high
  widget_control, idinfo.DC_freq_filter_high_text, get_value = str
  str = str[0]
  if is_valid_str_to_be_number(str) ne 1 then begin
    error_num = 256
    str_msg = bes_analyser_error_list(error_num)
    create_err_msg_window, str_msg, idinfo.base
    str = '10.0'
    widget_control, idinfo.DC_freq_filter_high_text, set_value = str
  endif
  info.bes_animation_window_data.DC_freq_filter_high = float(str)

; get play_type
  str = widget_info(idinfo.play_type_combo, /combobox_gettext)
  str = str[0]
  compare_str = ['n(t)', 'n1(t)', 'n1(t)/n0(t)']
  inx = where(str eq compare_str, count)
  if count le 0 then inx = 2
  info.bes_animation_window_data.inx_play_type = inx

; get by_time_avg_for_DC
  info.bes_animation_window_data.by_time_avg_for_DC = widget_info(idinfo.by_time_avg_for_DC_button, /button_set)

; get by_LPF_for_DC
  info.bes_animation_window_data.by_LPF_for_DC = widget_info(idinfo.by_LPF_for_DC_button, /button_set)

; get normalize
  info.bes_animation_window_data.normalize = widget_info(idinfo.normalize_button, /button_set)

; get norm_by_own_ch
  info.bes_animation_window_data.norm_by_own_ch = widget_info(idinfo.norm_by_own_ch_button, /button_set)

; get norm_by_all_ch
  info.bes_animation_window_data.norm_by_all_ch = widget_info(idinfo.norm_by_all_ch_button, /button_set)

; get show_BES_pos
  info.bes_animation_window_data.show_BES_pos = widget_info(idinfo.show_BES_pos_button, /button_set)

; get col_BES_pos_str
  str = widget_info(idinfo.col_BES_pos_combo, /combobox_gettext)
  str = str[0]
  info.bes_animation_window_data.col_BES_pos_str = str

; get inx_ctable
  str = widget_info(idinfo.ctable_combo, /combobox_gettext)
  str = str[0]
  widget_control, idinfo.ctable_combo, get_value = ctable_str_list
  inx = where(str eq ctable_str_list, count)
  if count le 0 then inx = 6
  info.bes_animation_window_data.inx_ctable = inx

; get inv_ctable
  info.bes_animation_window_data.inv_ctable = widget_info(idinfo.inv_ctable_button, /button_set)


; save the info structure
  widget_control, idinfo.id_main_base, set_uvalue = info

end


;===================================================================================
; This procedure controls events generated by bes_animation_window
;===================================================================================
; The function parameters:
;   1) 'event' is generated by the system and passed to the procedure 
;        for control purpose
;===================================================================================
pro bes_animation_window_event, event

; get the user value
  widget_control, event.top, get_uvalue = idinfo

; check if called due to kill_event
  if ( (tag_names(event, /structure_name) eq 'WIDGET_KILL_REQUEST') or $ 
       (event.id eq idinfo.close_button) ) then begin
  ; update the fields
    update_bes_animation_window, idinfo

  ; re-enable the ACTION buttons
    widget_control, idinfo.id_main_base, get_uvalue = info

    widget_control, info.id.main_window.basic_anal_action_button, sensitive = 1
    widget_control, info.id.main_window.dens_advanced_anal_action_button, sensitive = 1
    widget_control, info.id.main_window.vel_advanced_anal_action_button, sensitive = 1

  ; kill the window
    kill_bes_animation_window, idinfo.base
    return
  endif

; called due to play_type_combo
  if event.id eq idinfo.play_type_combo then begin
    if event.index  eq 0 then begin
      widget_control, idinfo.by_time_avg_for_DC_button, sensitive = 0
      widget_control, idinfo.by_LPF_for_DC_button, sensitive = 0
      widget_control, idinfo.avg_nt_text, sensitive = 0
      widget_control, idinfo.DC_freq_filter_high_text, sensitive = 0
    endif else begin
      widget_control, idinfo.by_time_avg_for_DC_button, sensitive = 1
      widget_control, idinfo.by_LPF_for_DC_button, sensitive = 1
      if widget_info(idinfo.by_time_avg_for_DC_button, /button_set) eq 1 then begin
        widget_control, idinfo.avg_nt_text, sensitive = 1
        widget_control, idinfo.DC_freq_filter_high_text, sensitive = 0
      endif else begin
        widget_control, idinfo.avg_nt_text, sensitive = 0
        widget_control, idinfo.DC_freq_filter_high_text, sensitive = 1
      endelse
    endelse

    return
  endif

; called due to by_time_avg_for_DC_button
  if event.id eq idinfo.by_time_avg_for_DC_button then begin
    if widget_info(idinfo.by_time_avg_for_DC_button, /button_set) eq 1 then $
      widget_control, idinfo.avg_nt_text, sensitive = 1 $
    else $
      widget_control, idinfo.avg_nt_text, sensitive = 0

    return
  endif

; called due to by_LPF_for_DC_button
  if event.id eq idinfo.by_LPF_for_DC_button then begin
    if widget_info(idinfo.by_LPF_for_DC_button, /button_set) eq 1 then $
      widget_control, idinfo.DC_freq_filter_high_text, sensitive = 1 $
    else $
      widget_control, idinfo.DC_freq_filter_high_text, sensitive = 0

    return
  endif

; called due to normalize_button
  if event.id eq idinfo.normalize_button then begin
    if widget_info(idinfo.normalize_button, /button_set) eq 1 then begin
      widget_control, idinfo.norm_by_own_ch_button, sensitive = 1
      widget_control, idinfo.norm_by_all_ch_button, sensitive = 1
    endif else begin
      widget_control, idinfo.norm_by_own_ch_button, sensitive = 0
      widget_control, idinfo.norm_by_all_ch_button, sensitive = 0
    endelse

    return
  endif

; called due to show_BES_pos_button
  if event.id eq idinfo.show_BES_pos_button then begin
    if widget_info(idinfo.show_BES_pos_button, /button_set) eq 1 then $
      widget_control, idinfo.col_BES_pos_combo, sensitive = 1 $
    else $
      widget_control, idinfo.col_BES_pos_combo, sensitive = 0

    return
  endif

; called due to plot_button or start_ani_button
  if ( (event.id eq idinfo.plot_button) or (event.id eq idinfo.start_ani_button) ) then begin
  ; show hour glass
    widget_control, /hourglass

  ; disable the buttons
    widget_control, idinfo.plot_button, sensitive = 0
    widget_control, idinfo.start_ani_button, sensitive = 0
    widget_control, idinfo.save_options_button, sensitive = 0
    widget_control, idinfo.load_options_button, sensitive = 0
    widget_control, idinfo.help_button, sensitive = 0
    widget_control, idinfo.close_button, sensitive = 0

  ; update the fields
    update_bes_animation_window, idinfo

  ; plot the data
    if event.id eq idinfo.plot_button then $
      result = ctrl_plot_bes_animation(idinfo) $
    else $
      result = ctrl_plot_bes_animation(idinfo, /animation)

    if result.erc ne 0 then begin
      create_err_msg_window, result.errmsg, idinfo.base
    endif

  ; enable the buttons
    widget_control, idinfo.plot_button, sensitive = 1
    widget_control, idinfo.start_ani_button, sensitive = 1
    widget_control, idinfo.save_options_button, sensitive = 1
    widget_control, idinfo.load_options_button, sensitive = 1
    widget_control, idinfo.help_button, sensitive = 1
    widget_control, idinfo.close_button, sensitive = 1

    return
  endif


; called due to help_button
  if event.id eq idinfo.help_button then begin
    filename = 'BES_Analyser_Animation_Explain.pdf'
    help_result = open_help_file(filename)
    if help_result.erc ne 0 then begin
      create_err_msg_window, help_result.errmsg, idinfo.base
    endif
    return
  endif

; called due to load_options_button
  if event.id eq idinfo.load_options_button then begin
  ; set the file extension
    file_extension = '.bes_ani'
  ; get the filename
    filename = create_load_options_window(idinfo.id_main_base, file_extension)
  ; load the options
    if filename ne '' then begin
      result = load_options_info(idinfo.id_main_base, idinfo, filename, file_extension)
      if result ne 0 then begin
        errmsg = bes_analyser_error_list(result)
        create_err_msg_window, errmsg, idinfo.base
      endif
    endif

    return
  endif

; called due to save_options_button
  if event.id eq idinfo.save_options_button then begin
  ; set the file extension
    file_extension = '.bes_ani'
  ; update the fields
    update_bes_animation_window, idinfo
  ; create the window
    create_save_options_window, idinfo.id_main_base, file_extension

    return
  endif

end


;===================================================================================
; This procedure updates the info field for bes_dens_spec_window
;===================================================================================
; The function parameters:
;   1) 'idinfo' is a structure that is saved as uvalue under bes_dens_spec_window
;===================================================================================
pro update_bes_dens_spec_window, idinfo

; get the info structure
  widget_control, idinfo.id_main_base, get_uvalue = info

; get calc_in_IDL
  info.dens_spec_window_data.calc_in_IDL = widget_info(idinfo.calc_in_IDL_button, /button_set)

; get calc_in_CUDA
  info.dens_spec_window_data.calc_in_CUDA = widget_info(idinfo.calc_in_CUDA_button, /button_set)

; get BES_ch_sel1
  for i = 0, 31 do $
    info.dens_spec_window_data.BES_ch_sel1[i] = widget_info(idinfo.BES_ch_sel1_button[i], /button_set)

; get BES_ch_sel2
  for i = 0, 31 do $
    info.dens_spec_window_data.BES_ch_sel2[i] = widget_info(idinfo.BES_ch_sel2_button[i], /button_set)

; get frequency filtering range
  widget_control, idinfo.freq_filter_low_text, get_value = str1
  str1 = str1[0]
  widget_control, idinfo.freq_filter_high_text, get_value = str2
  str2 = str2[0]
  if is_valid_str_to_be_number(str1) ne 1 then begin
    error_num = 252
    str_msg = bes_analyser_error_list(error_num)
    create_err_msg_window, str_msg, idinfo.base
    str1 = '0.0'
    widget_control, idinfo.freq_filter_low_text, set_value = str1
  endif
  if is_valid_str_to_be_number(str2) ne 1 then begin
    error_num = 253
    str_msg = bes_analyser_error_list(error_num)
    create_err_msg_window, str_msg, idinfo.base
    str2 = '1000.0'
    widget_control, idinfo.freq_filter_high_text, set_value = str2
  endif
  info.dens_spec_window_data.freq_filter_low = float(str1)
  info.dens_spec_window_data.freq_filter_high = float(str2)

; get calc_spectrum
  info.dens_spec_window_data.calc_spectrum = widget_info(idinfo.calc_spectrum_button, /button_set)

; get calc_spectrogram
  info.dens_spec_window_data.calc_spectrogram = widget_info(idinfo.calc_spectrogram_button, /button_set)

; get calc_power
  info.dens_spec_window_data.calc_power = widget_info(idinfo.calc_power_button, /button_set)

; get calc_phase
  info.dens_spec_window_data.calc_phase = widget_info(idinfo.calc_phase_button, /button_set)

; get num_pts_per_subwindow
  str = widget_info(idinfo.num_pts_per_subwindow_combo, /combobox_gettext)
  str = str[0]
  widget_control, idinfo.num_pts_per_subwindow_combo, get_value = compare_str
  inx = where(str eq compare_str, count)
  if count le 0 then begin
    inx = 0
    str = compare_str[0]
    widget_control, idinfo.num_pts_per_subwindow_combo, set_combobox_select = inx
  endif
  info.dens_spec_window_data.num_pts_per_subwindow = long(str)

; get num_bins_to_average
  widget_control, idinfo.num_bins_to_average_text, get_value = str
  str = str[0]
  if is_valid_str_to_be_number(str) ne 1 then begin
    error_num = 300
    str_msg = bes_analyser_error_list(error_num)
    create_err_msg_window, str_msg, idinfo.base
    str = '10'
    widget_control, idinfo.num_bins_to_average_text, set_value = str
  endif
  if ( (long(str) lt 1) and (info.dens_spec_window_data.calc_spectrogram eq 1) ) then begin
    error_num = 302
    str_msg = bes_analyser_error_list(error_num)
    create_err_msg_window, str_msg, idinfo.base
    str = '10'
    widget_control, idinfo.num_bins_to_average_text, set_value = str
  endif
  info.dens_spec_window_data.num_bins_to_average = long(str)

; get frac_overlap_subwindow
  widget_control, idinfo.frac_overlap_subwindow_slider, get_value = int_pos
  info.dens_spec_window_data.frac_overlap_subwindow = float(int_pos) * 0.1

;get norm_by_DC
  str = widget_info(idinfo.norm_by_DC_combo, /combobox_gettext)
  str = str[0]
  widget_control, idinfo.norm_by_DC_combo, get_value = compare_str
  inx = where(str eq compare_str, count)
  if count le 0 then begin
    inx = 0
    widget_control, idinfo.norm_by_DC_combo, set_combobox_select = inx
  endif
  info.dens_spec_window_data.norm_by_DC = inx

;get use_hanning_window
  str = widget_info(idinfo.use_hanning_window_combo, /combobox_gettext)
  str = str[0]
  widget_control, idinfo.use_hanning_window_combo, get_value = compare_str
  inx = where(str eq compare_str, count)
  if count le 0 then begin
    inx = 0
    widget_control, idinfo.use_hanning_window_combo, set_combobox_select = inx
  endif
  info.dens_spec_window_data.use_hanning_window = inx

; get remove_large_structure
  str = widget_info(idinfo.remove_large_structure_combo, /combobox_gettext)
  str = str[0]
  widget_control, idinfo.remove_large_structure_combo, get_value = compare_str
  inx = where(str eq compare_str, count)
  if count le 0 then begin
    inx = 0
    widget_control, idinfo.remove_large_structure_combo, set_combobox_select = inx
  endif
  info.dens_spec_window_data.remove_large_structure = inx

; save the info structure
  widget_control, idinfo.id_main_base, set_uvalue = info

end


;===================================================================================
; This procedure controls events generated by bes_dens_spec_window
;===================================================================================
; The function parameters:
;   1) 'event' is generated by the system and passed to the procedure 
;        for control purpose
;===================================================================================
pro bes_dens_spec_window_event, event

; get the user value
  widget_control, event.top, get_uvalue = idinfo

; check if called due to kill_event
  if ( (tag_names(event, /structure_name) eq 'WIDGET_KILL_REQUEST') or $ 
       (event.id eq idinfo.close_button) ) then begin
  ; update the fields
    update_bes_dens_spec_window, idinfo

  ; re-enable the ACTION buttons
    widget_control, idinfo.id_main_base, get_uvalue = info

    widget_control, info.id.main_window.basic_anal_action_button, sensitive = 1
    widget_control, info.id.main_window.dens_advanced_anal_action_button, sensitive = 1
    widget_control, info.id.main_window.vel_advanced_anal_action_button, sensitive = 1

  ; kill the window
    kill_dens_spec_window, idinfo.base
    return
  endif

; event due to BES_ch_sel1_button
  inx = where(event.id eq idinfo.BES_ch_sel1_button, count)
  if count gt 0 then begin
    make_bes_ch_button_exclusive, inx, idinfo.BES_ch_sel1_button 
    return
  endif

; event due to BES_ch_sel2_button
  inx = where(event.id eq idinfo.BES_ch_sel2_button, count)
  if count gt 0 then begin
    make_bes_ch_button_exclusive, inx, idinfo.BES_ch_sel2_button 
    return
  endif

; event due to calc_spectrum_button
  if event.id eq idinfo.calc_spectrum_button then begin
  ; if calc_spectrum_button is set, then deactivate num_bins_to_average_text
    if widget_info(idinfo.calc_spectrum_button, /button_set) eq 1 then $
      widget_control, idinfo.num_bins_to_average_text, sensitive = 0 $
    else $
      widget_control, idinfo.num_bins_to_average_text, sensitive = 1
    return
  endif

; event due to calc_spectrogram_button
  if event.id eq idinfo.calc_spectrogram_button then begin
  ;if calc_spectrogram_button is set, then activate num_bins_to_average_text
    if widget_info(idinfo.calc_spectrogram_button, /button_set) eq 1 then $
      widget_control, idinfo.num_bins_to_average_text, sensitive = 1 $
    else $
      widget_control, idinfo.num_bins_to_average_text, sensitive = 0
    return
  endif

; event due to frac_overlap_subwindow_slider
  if event.id eq idinfo.frac_overlap_subwindow_slider then begin
    widget_control, idinfo.frac_overlap_subwindow_slider, get_value = int_pos
    str = string(int_pos*0.1, format='(f0.1)')
    widget_control, idinfo.frac_overlap_subwindow_label, set_value = str
    return
  endif

; event due to plot or oplot button
  if ( (event.id eq idinfo.plot_button) or (event.id eq idinfo.oplot_button) ) then begin
  ; show hour glass
    widget_control, /hourglass

  ; disable the buttons
    widget_control, idinfo.plot_button, sensitive = 0
    widget_control, idinfo.oplot_button, sensitive = 0
    widget_control, idinfo.save_options_button, sensitive = 0
    widget_control, idinfo.load_options_button, sensitive = 0
    widget_control, idinfo.help_button, sensitive = 0
    widget_control, idinfo.close_button, sensitive = 0

  ; update the fields
    update_bes_dens_spec_window, idinfo

  ; plot the data
    if event.id eq idinfo.plot_button then $
      result = ctrl_plot_dens_spec(idinfo) $
    else $
      result = ctrl_plot_dens_spec(idinfo, /overplot)

    if result.erc ne 0 then begin
      create_err_msg_window, result.errmsg, idinfo.base
    endif

  ; enable the buttons
    widget_control, idinfo.plot_button, sensitive = 1
    widget_control, idinfo.oplot_button, sensitive = 1
    widget_control, idinfo.save_options_button, sensitive = 1
    widget_control, idinfo.load_options_button, sensitive = 1
    widget_control, idinfo.help_button, sensitive = 1
    widget_control, idinfo.close_button, sensitive = 1

    return
  endif

; event due to help button
  if event.id eq idinfo.help_button then begin
    filename = 'BES_Analyser_Dens_Spec_Explain.pdf'
    help_result = open_help_file(filename)
    if help_result.erc ne 0 then begin
      create_err_msg_window, help_result.errmsg, idinfo.base
    endif
    return
  endif

; called due to load_options_button
  if event.id eq idinfo.load_options_button then begin
  ; set the file extension
    file_extension = '.dens_spec'
  ; get the filename
    filename = create_load_options_window(idinfo.id_main_base, file_extension)
  ; load the options
    if filename ne '' then begin
      result = load_options_info(idinfo.id_main_base, idinfo, filename, file_extension)
      if result ne 0 then begin
        errmsg = bes_analyser_error_list(result)
        create_err_msg_window, errmsg, idinfo.base
      endif
    endif

    return
  endif

; called due to save_options_button
  if event.id eq idinfo.save_options_button then begin
  ; set the file extension
    file_extension = '.dens_spec'
  ; update the fields
    update_bes_dens_spec_window, idinfo
  ; create the window
    create_save_options_window, idinfo.id_main_base, file_extension

    return
  endif

end



;===================================================================================
; This procedure updates the info field for bes_dens_coh_window
;===================================================================================
; The function parameters:
;   1) 'idinfo' is a structure that is saved as uvalue under bes_dens_spec_window
;===================================================================================
pro update_bes_dens_coh_window, idinfo

; get the info structure
  widget_control, idinfo.id_main_base, get_uvalue = info

; get calc_in_IDL
  info.dens_coh_window_data.calc_in_IDL = widget_info(idinfo.calc_in_IDL_button, /button_set)

; get calc_in_CUDA
  info.dens_coh_window_data.calc_in_CUDA = widget_info(idinfo.calc_in_CUDA_button, /button_set)

; get BES_ch_sel1
  for i = 0, 31 do $
    info.dens_coh_window_data.BES_ch_sel1[i] = widget_info(idinfo.BES_ch_sel1_button[i], /button_set)

; get BES_ch_sel2
  for i = 0, 31 do $
    info.dens_coh_window_data.BES_ch_sel2[i] = widget_info(idinfo.BES_ch_sel2_button[i], /button_set)

; get frequency filtering range
  widget_control, idinfo.freq_filter_low_text, get_value = str1
  str1 = str1[0]
  widget_control, idinfo.freq_filter_high_text, get_value = str2
  str2 = str2[0]
  if is_valid_str_to_be_number(str1) ne 1 then begin
    error_num = 252
    str_msg = bes_analyser_error_list(error_num)
    create_err_msg_window, str_msg, idinfo.base
    str1 = '0.0'
    widget_control, idinfo.freq_filter_low_text, set_value = str1
  endif
  if is_valid_str_to_be_number(str2) ne 1 then begin
    error_num = 253
    str_msg = bes_analyser_error_list(error_num)
    create_err_msg_window, str_msg, idinfo.base
    str2 = '1000.0'
    widget_control, idinfo.freq_filter_high_text, set_value = str2
  endif
  info.dens_coh_window_data.freq_filter_low = float(str1)
  info.dens_coh_window_data.freq_filter_high = float(str2)

; get calc_spectrum
  info.dens_coh_window_data.calc_spectrum = widget_info(idinfo.calc_spectrum_button, /button_set)

; get calc_spectrogram
  info.dens_coh_window_data.calc_spectrogram = widget_info(idinfo.calc_spectrogram_button, /button_set)

; get calc_power
  info.dens_coh_window_data.calc_power = widget_info(idinfo.calc_power_button, /button_set)

; get calc_phase
  info.dens_coh_window_data.calc_phase = widget_info(idinfo.calc_phase_button, /button_set)

; get num_pts_per_subwindow
  str = widget_info(idinfo.num_pts_per_subwindow_combo, /combobox_gettext)
  str = str[0]
  widget_control, idinfo.num_pts_per_subwindow_combo, get_value = compare_str
  inx = where(str eq compare_str, count)
  if count le 0 then begin
    inx = 0
    str = compare_str[0]
    widget_control, idinfo.num_pts_per_subwindow_combo, set_combobox_select = inx
  endif
  info.dens_coh_window_data.num_pts_per_subwindow = long(str)

; get num_bins_to_average
  widget_control, idinfo.num_bins_to_average_text, get_value = str
  str = str[0]
  if is_valid_str_to_be_number(str) ne 1 then begin
    error_num = 300
    str_msg = bes_analyser_error_list(error_num)
    create_err_msg_window, str_msg, idinfo.base
    str = '10'
    widget_control, idinfo.num_bins_to_average_text, set_value = str
  endif
  if ( (long(str) lt 1) and (info.dens_coh_window_data.calc_spectrogram eq 1) ) then begin
    error_num = 302
    str_msg = bes_analyser_error_list(error_num)
    create_err_msg_window, str_msg, idinfo.base
    str = '10'
    widget_control, idinfo.num_bins_to_average_text, set_value = str
  endif
  info.dens_coh_window_data.num_bins_to_average = long(str)

; get frac_overlap_subwindow
  widget_control, idinfo.frac_overlap_subwindow_slider, get_value = int_pos
  info.dens_coh_window_data.frac_overlap_subwindow = float(int_pos) * 0.1

;get use_hanning_window
  str = widget_info(idinfo.use_hanning_window_combo, /combobox_gettext)
  str = str[0]
  widget_control, idinfo.use_hanning_window_combo, get_value = compare_str
  inx = where(str eq compare_str, count)
  if count le 0 then begin
    inx = 0
    widget_control, idinfo.use_hanning_window_combo, set_combobox_select = inx
  endif
  info.dens_coh_window_data.use_hanning_window = inx

; get remove_large_structure
  str = widget_info(idinfo.remove_large_structure_combo, /combobox_gettext)
  str = str[0]
  widget_control, idinfo.remove_large_structure_combo, get_value = compare_str
  inx = where(str eq compare_str, count)
  if count le 0 then begin
    inx = 0
    widget_control, idinfo.remove_large_structure_combo, set_combobox_select = inx
  endif
  info.dens_coh_window_data.remove_large_structure = inx

; save the info structure
  widget_control, idinfo.id_main_base, set_uvalue = info

end


;===================================================================================
; This procedure controls events generated by bes_dens_coh_window
;===================================================================================
; The function parameters:
;   1) 'event' is generated by the system and passed to the procedure 
;        for control purpose
;===================================================================================
pro bes_dens_coh_window_event, event

; get the user value
  widget_control, event.top, get_uvalue = idinfo

; check if called due to kill_event
  if ( (tag_names(event, /structure_name) eq 'WIDGET_KILL_REQUEST') or $ 
       (event.id eq idinfo.close_button) ) then begin
  ; update the fields
    update_bes_dens_coh_window, idinfo

  ; re-enable the ACTION buttons
    widget_control, idinfo.id_main_base, get_uvalue = info

    widget_control, info.id.main_window.basic_anal_action_button, sensitive = 1
    widget_control, info.id.main_window.dens_advanced_anal_action_button, sensitive = 1
    widget_control, info.id.main_window.vel_advanced_anal_action_button, sensitive = 1

  ; kill the window
    kill_dens_coh_window, idinfo.base
    return
  endif

; event due to BES_ch_sel1_button
  inx = where(event.id eq idinfo.BES_ch_sel1_button, count)
  if count gt 0 then begin
    make_bes_ch_button_exclusive, inx, idinfo.BES_ch_sel1_button 
    return
  endif

; event due to BES_ch_sel2_button
  inx = where(event.id eq idinfo.BES_ch_sel2_button, count)
  if count gt 0 then begin
    make_bes_ch_button_exclusive, inx, idinfo.BES_ch_sel2_button 
    return
  endif

; event due to calc_spectrum_button
  if event.id eq idinfo.calc_spectrum_button then begin
  ; if calc_spectrum_button is set, then deactivate num_bins_to_average_text
    if widget_info(idinfo.calc_spectrum_button, /button_set) eq 1 then $
      widget_control, idinfo.num_bins_to_average_text, sensitive = 0 $
    else $
      widget_control, idinfo.num_bins_to_average_text, sensitive = 1
    return
  endif

; event due to calc_spectrogram_button
  if event.id eq idinfo.calc_spectrogram_button then begin
  ;if calc_spectrogram_button is set, then activate num_bins_to_average_text
    if widget_info(idinfo.calc_spectrogram_button, /button_set) eq 1 then $
      widget_control, idinfo.num_bins_to_average_text, sensitive = 1 $
    else $
      widget_control, idinfo.num_bins_to_average_text, sensitive = 0
    return
  endif

; event due to frac_overlap_subwindow_slider
  if event.id eq idinfo.frac_overlap_subwindow_slider then begin
    widget_control, idinfo.frac_overlap_subwindow_slider, get_value = int_pos
    str = string(int_pos*0.1, format='(f0.1)')
    widget_control, idinfo.frac_overlap_subwindow_label, set_value = str
    return
  endif

; event due to plot or oplot button
  if ( (event.id eq idinfo.plot_button) or (event.id eq idinfo.oplot_button) ) then begin
  ; show hour glass
    widget_control, /hourglass

  ; disable the buttons
    widget_control, idinfo.plot_button, sensitive = 0
    widget_control, idinfo.oplot_button, sensitive = 0
    widget_control, idinfo.save_options_button, sensitive = 0
    widget_control, idinfo.load_options_button, sensitive = 0
    widget_control, idinfo.help_button, sensitive = 0
    widget_control, idinfo.close_button, sensitive = 0

  ; update the fields
    update_bes_dens_coh_window, idinfo

  ; plot the data
    if event.id eq idinfo.plot_button then $
      result = ctrl_plot_dens_coh(idinfo) $
    else $
      result = ctrl_plot_dens_coh(idinfo, /overplot)

    if result.erc ne 0 then begin
      create_err_msg_window, result.errmsg, idinfo.base
    endif

  ; enable the buttons
    widget_control, idinfo.plot_button, sensitive = 1
    widget_control, idinfo.oplot_button, sensitive = 1
    widget_control, idinfo.save_options_button, sensitive = 1
    widget_control, idinfo.load_options_button, sensitive = 1
    widget_control, idinfo.help_button, sensitive = 1
    widget_control, idinfo.close_button, sensitive = 1

    return
  endif

; event due to help button
  if event.id eq idinfo.help_button then begin
    filename = 'BES_Analyser_Dens_Spec_Explain.pdf'
    help_result = open_help_file(filename)
    if help_result.erc ne 0 then begin
      create_err_msg_window, help_result.errmsg, idinfo.base
    endif
    return
  endif

; called due to load_options_button
  if event.id eq idinfo.load_options_button then begin
  ; set the file extension
    file_extension = '.dens_coh'
  ; get the filename
    filename = create_load_options_window(idinfo.id_main_base, file_extension)
  ; load the options
    if filename ne '' then begin
      result = load_options_info(idinfo.id_main_base, idinfo, filename, file_extension)
      if result ne 0 then begin
        errmsg = bes_analyser_error_list(result)
        create_err_msg_window, errmsg, idinfo.base
      endif
    endif

    return
  endif

; called due to save_options_button
  if event.id eq idinfo.save_options_button then begin
  ; set the file extension
    file_extension = '.dens_coh'
  ; update the fields
    update_bes_dens_coh_window, idinfo
  ; create the window
    create_save_options_window, idinfo.id_main_base, file_extension

    return
  endif

end


;===================================================================================
; This procedure updates the info field for bes_dens_temporal_corr_window
;===================================================================================
; The function parameters:
;   1) 'idinfo' is a structure that is saved as uvalue under bes_dens_temporal_corr_window
;===================================================================================
pro update_bes_dens_temporal_corr_window, idinfo

; get the info structure
  widget_control, idinfo.id_main_base, get_uvalue = info

; get calc_in_IDL
  info.dens_temp_corr_window_data.calc_in_IDL = widget_info(idinfo.calc_in_IDL_button, /button_set)

; get calc_in_CUDA
  info.dens_temp_corr_window_data.calc_in_CUDA = widget_info(idinfo.calc_in_CUDA_button, /button_set)

; get BES_ch_sel1
  for i = 0, 31 do $
    info.dens_temp_corr_window_data.BES_ch_sel1[i] = widget_info(idinfo.BES_ch_sel1_button[i], /button_set)

; get BES_ch_sel2
  for i = 0, 31 do $
    info.dens_temp_corr_window_data.BES_ch_sel2[i] = widget_info(idinfo.BES_ch_sel2_button[i], /button_set)

; get frequency filtering range
  widget_control, idinfo.freq_filter_low_text, get_value = str1
  str1 = str1[0]
  widget_control, idinfo.freq_filter_high_text, get_value = str2
  str2 = str2[0]
  if is_valid_str_to_be_number(str1) ne 1 then begin
    error_num = 252
    str_msg = bes_analyser_error_list(error_num)
    create_err_msg_window, str_msg, idinfo.base
    str1 = '0.0'
    widget_control, idinfo.freq_filter_low_text, set_value = str1
  endif
  if is_valid_str_to_be_number(str2) ne 1 then begin
    error_num = 253
    str_msg = bes_analyser_error_list(error_num)
    create_err_msg_window, str_msg, idinfo.base
    str2 = '1000.0'
    widget_control, idinfo.freq_filter_high_text, set_value = str2
  endif
  info.dens_temp_corr_window_data.freq_filter_low = float(str1)
  info.dens_temp_corr_window_data.freq_filter_high = float(str2)

; get time-delay range
  widget_control, idinfo.time_delay_low_text, get_value = str1
  str1 = str1[0]
  widget_control, idinfo.time_delay_high_text, get_value = str2
  str2 = str2[0]
  if is_valid_str_to_be_number(str1) ne 1 then begin
    error_num = 350
    str_msg = bes_analyser_error_list(error_num)
    create_err_msg_window, str_msg, idinfo.base
    str1 = '-50.0'
    widget_control, idinfo.time_delay_low_text, set_value = str1
  endif
  if is_valid_str_to_be_number(str2) ne 1 then begin
    error_num = 351
    str_msg = bes_analyser_error_list(error_num)
    create_err_msg_window, str_msg, idinfo.base
    str2 = '50.0'
    widget_control, idinfo.time_delay_high_text, set_value = str2
  endif
  info.dens_temp_corr_window_data.time_delay_low = float(str1)
  info.dens_temp_corr_window_data.time_delay_high = float(str2)

; get calc_covariance
  info.dens_temp_corr_window_data.calc_covariance = widget_info(idinfo.calc_covariance_button, /button_set)

; get calc_correlation
  info.dens_temp_corr_window_data.calc_correlation = widget_info(idinfo.calc_correlation_button, /button_set)

; get calc_fcn_tau_time
  info.dens_temp_corr_window_data.calc_fcn_tau_time = widget_info(idinfo.calc_fcn_tau_time_button, /button_set)

; get calc_fcn_tau
  info.dens_temp_corr_window_data.calc_fcn_tau = widget_info(idinfo.calc_fcn_tau_button, /button_set)

; get num_bins_to_average
  widget_control, idinfo.num_bins_to_average_text, get_value = str
  str = str[0]
  if is_valid_str_to_be_number(str) ne 1 then begin
    error_num = 300
    str_msg = bes_analyser_error_list(error_num)
    create_err_msg_window, str_msg, idinfo.base
    str = '10'
    widget_control, idinfo.num_bins_to_average_text, set_value = str
  endif
  if ( (long(str) lt 1) and (info.dens_temp_corr_window_data.calc_fcn_tau_time eq 1) ) then begin
    error_num = 352
    str_msg = bes_analyser_error_list(error_num)
    create_err_msg_window, str_msg, idinfo.base
    str = '10'
    widget_control, idinfo.num_bins_to_average_text, set_value = str
  endif
  info.dens_temp_corr_window_data.num_bins_to_average = long(str)

; get frac_overlap_subwindow
  widget_control, idinfo.frac_overlap_subwindow_slider, get_value = int_pos
  info.dens_temp_corr_window_data.frac_overlap_subwindow = float(int_pos) * 0.1

;get use_hanning_window
  str = widget_info(idinfo.use_hanning_window_combo, /combobox_gettext)
  str = str[0]
  widget_control, idinfo.use_hanning_window_combo, get_value = compare_str
  inx = where(str eq compare_str, count)
  if count le 0 then begin
    inx = 0
    widget_control, idinfo.use_hanning_window_combo, set_combobox_select = inx
  endif
  info.dens_temp_corr_window_data.use_hanning_window = inx

; get remove_large_structure
  str = widget_info(idinfo.remove_large_structure_combo, /combobox_gettext)
  str = str[0]
  widget_control, idinfo.remove_large_structure_combo, get_value = compare_str
  inx = where(str eq compare_str, count)
  if count le 0 then begin
    inx = 0
    widget_control, idinfo.remove_large_structure_combo, set_combobox_select = inx
  endif
  info.dens_temp_corr_window_data.remove_large_structure = inx

; get num_pts_to_remove_ph_peak
  widget_control, idinfo.num_pts_to_remove_ph_peak_text, get_value = str
  str = str[0]
  if is_valid_str_to_be_number(str) ne 1 then begin
    error_num = 353
    str_msg = bes_analyser_error_list(error_num)
    create_err_msg_window, str_msg, idinfo.base
    str = '0'
    widget_control, idinfo.num_bins_to_average_text, set_value = str
  endif
  if (long(str) lt 0) then begin
    error_num = 353
    str_msg = bes_analyser_error_list(error_num)
    create_err_msg_window, str_msg, idinfo.base
    str = '0'
    widget_control, idinfo.num_bins_to_average_text, set_value = str
  endif
  info.dens_temp_corr_window_data.num_pts_to_remove_ph_peak = long(str)

; get show_filter_response
  info.dens_temp_corr_window_data.show_filter_response = widget_info(idinfo.show_filter_response_button, /button_set)

; get show_envelope
  info.dens_temp_corr_window_data.show_envelope = widget_info(idinfo.show_envelope_button, /button_set)


; save the info structure
  widget_control, idinfo.id_main_base, set_uvalue = info

end


;===================================================================================
; This procedure controls events generated by bes_dens_temporal_corr_window
;===================================================================================
; The function parameters:
;   1) 'event' is generated by the system and passed to the procedure 
;        for control purpose
;===================================================================================
pro bes_dens_temporal_corr_window_event, event

; get the user value
  widget_control, event.top, get_uvalue = idinfo

; check if called due to kill_event
  if ( (tag_names(event, /structure_name) eq 'WIDGET_KILL_REQUEST') or $ 
       (event.id eq idinfo.close_button) ) then begin
  ; update the fields
    update_bes_dens_temporal_corr_window, idinfo

  ; re-enable the ACTION buttons
    widget_control, idinfo.id_main_base, get_uvalue = info

    widget_control, info.id.main_window.basic_anal_action_button, sensitive = 1
    widget_control, info.id.main_window.dens_advanced_anal_action_button, sensitive = 1
    widget_control, info.id.main_window.vel_advanced_anal_action_button, sensitive = 1

  ; kill the window
    kill_dens_temporal_corr_window, idinfo.base
    return
  endif

; event due to BES_ch_sel1_button
  inx = where(event.id eq idinfo.BES_ch_sel1_button, count)
  if count gt 0 then begin
    make_bes_ch_button_exclusive, inx, idinfo.BES_ch_sel1_button 
    return
  endif

; event due to BES_ch_sel2_button
  inx = where(event.id eq idinfo.BES_ch_sel2_button, count)
  if count gt 0 then begin
    make_bes_ch_button_exclusive, inx, idinfo.BES_ch_sel2_button 
    return
  endif

; event due to calc_spectrum_button
  if event.id eq idinfo.calc_fcn_tau_button then begin
  ; if calc_fcn_tau_button is set, then deactivate num_bins_to_average_text
    if widget_info(idinfo.calc_fcn_tau_button, /button_set) eq 1 then $
      widget_control, idinfo.num_bins_to_average_text, sensitive = 0 $
    else $
      widget_control, idinfo.num_bins_to_average_text, sensitive = 1
    return
  endif

; event due to calc_spectrogram_button
  if event.id eq idinfo.calc_fcn_tau_time_button then begin
  ;if calc_spectrogram_button is set, then activate num_bins_to_average_text
    if widget_info(idinfo.calc_fcn_tau_time_button, /button_set) eq 1 then $
      widget_control, idinfo.num_bins_to_average_text, sensitive = 1 $
    else $
      widget_control, idinfo.num_bins_to_average_text, sensitive = 0
    return
  endif

; event due to frac_overlap_subwindow_slider
  if event.id eq idinfo.frac_overlap_subwindow_slider then begin
    widget_control, idinfo.frac_overlap_subwindow_slider, get_value = int_pos
    str = string(int_pos*0.1, format='(f0.1)')
    widget_control, idinfo.frac_overlap_subwindow_label, set_value = str
    return
  endif

; event due to plot or oplot button
  if ( (event.id eq idinfo.plot_button) or (event.id eq idinfo.oplot_button) ) then begin
  ; show hour glass
    widget_control, /hourglass

  ; disable the buttons
    widget_control, idinfo.plot_button, sensitive = 0
    widget_control, idinfo.oplot_button, sensitive = 0
    widget_control, idinfo.save_options_button, sensitive = 0
    widget_control, idinfo.load_options_button, sensitive = 0
    widget_control, idinfo.help_button, sensitive = 0
    widget_control, idinfo.close_button, sensitive = 0

  ; update the fields
    update_bes_dens_temporal_corr_window, idinfo

  ; plot the data
    if event.id eq idinfo.plot_button then $
      result = ctrl_plot_dens_temp_corr(idinfo) $
    else $
      result = ctrl_plot_dens_temp_corr(idinfo, /overplot)

    if result.erc ne 0 then begin
      create_err_msg_window, result.errmsg, idinfo.base
    endif

  ; enable the buttons
    widget_control, idinfo.plot_button, sensitive = 1
    widget_control, idinfo.oplot_button, sensitive = 1
    widget_control, idinfo.save_options_button, sensitive = 1
    widget_control, idinfo.load_options_button, sensitive = 1
    widget_control, idinfo.help_button, sensitive = 1
    widget_control, idinfo.close_button, sensitive = 1

    return
  endif

; event due to help button
  if event.id eq idinfo.help_button then begin
    filename = 'BES_Analyser_Dens_Temp_Corr_Explain.pdf'
    help_result = open_help_file(filename)
    if help_result.erc ne 0 then begin
      create_err_msg_window, help_result.errmsg, idinfo.base
    endif
    return
  endif

; called due to load_options_button
  if event.id eq idinfo.load_options_button then begin
  ; set the file extension
    file_extension = '.dens_tcorr'
  ; get the filename
    filename = create_load_options_window(idinfo.id_main_base, file_extension)
  ; load the options
    if filename ne '' then begin
      result = load_options_info(idinfo.id_main_base, idinfo, filename, file_extension)
      if result ne 0 then begin
        errmsg = bes_analyser_error_list(result)
        create_err_msg_window, errmsg, idinfo.base
      endif
    endif

    return
  endif

; called due to save_options_button
  if event.id eq idinfo.save_options_button then begin
  ; set the file extension
    file_extension = '.dens_tcorr'
  ; update the fields
    update_bes_dens_temporal_corr_window, idinfo
  ; create the window
    create_save_options_window, idinfo.id_main_base, file_extension

    return
  endif


end


;===================================================================================
; This procedure updates the info field for bes_dens_spa_temp_corr_window
;===================================================================================
; The function parameters:
;   1) 'idinfo' is a structure that is saved as uvalue under bes_dens_spa_temp_corr_window
;===================================================================================
pro update_bes_dens_spa_temp_corr_window, idinfo

; get the info structure
  widget_control, idinfo.id_main_base, get_uvalue = info

; get the calc_in_IDL
  info.dens_spa_temp_corr_window_data.calc_in_IDL = widget_info(idinfo.calc_in_IDL_button, /button_set)

; get the calc_in_CUDA
  info.dens_spa_temp_corr_window_data.calc_in_CUDA = widget_info(idinfo.calc_in_CUDA_button, /button_set)

; get the calc_pol_spa
  info.dens_spa_temp_corr_window_data.calc_pol_spa = widget_info(idinfo.calc_pol_spa_button, /button_set)

; get the calc_rad_spa
  info.dens_spa_temp_corr_window_data.calc_rad_spa = widget_info(idinfo.calc_rad_spa_button, /button_set)

; get the BES_ch_sel
  nch = n_elements(info.dens_spa_temp_corr_window_data.BES_ch_sel)
  for i = 0, nch - 1 do $
    info.dens_spa_temp_corr_window_data.BES_ch_sel[i] = widget_info(idinfo.BES_Ch_button[i], /button_set)

; get the BES_RAD_ch_sel
  nch = n_elements(info.dens_spa_temp_corr_window_data.BES_RAD_ch_sel)
  for i = 0, nch - 1 do $
    info.dens_spa_temp_corr_window_data.BES_RAD_ch_sel[i] = widget_info(idinfo.RAD_Ch_button[i], /button_set)

; get the BES_POL_ch_sel
  nch = n_elements(info.dens_spa_temp_corr_window_data.BES_POL_ch_sel)
  for i = 0, nch - 1 do $
    info.dens_spa_temp_corr_window_data.BES_POL_ch_sel[i] = widget_info(idinfo.POL_Ch_button[i], /button_set)


; get frequency filtering range
  widget_control, idinfo.freq_filter_low_text, get_value = str1
  str1 = str1[0]
  widget_control, idinfo.freq_filter_high_text, get_value = str2
  str2 = str2[0]
  if is_valid_str_to_be_number(str1) ne 1 then begin
    error_num = 252
    str_msg = bes_analyser_error_list(error_num)
    create_err_msg_window, str_msg, idinfo.base
    str1 = '0.0'
    widget_control, idinfo.freq_filter_low_text, set_value = str1
  endif
  if is_valid_str_to_be_number(str2) ne 1 then begin
    error_num = 253
    str_msg = bes_analyser_error_list(error_num)
    create_err_msg_window, str_msg, idinfo.base
    str2 = '1000.0'
    widget_control, idinfo.freq_filter_high_text, set_value = str2
  endif
  info.dens_spa_temp_corr_window_data.freq_filter_low = float(str1)
  info.dens_spa_temp_corr_window_data.freq_filter_high = float(str2)

; get time-delay range
  widget_control, idinfo.time_delay_low_text, get_value = str1
  str1 = str1[0]
  widget_control, idinfo.time_delay_high_text, get_value = str2
  str2 = str2[0]
  if is_valid_str_to_be_number(str1) ne 1 then begin
    error_num = 350
    str_msg = bes_analyser_error_list(error_num)
    create_err_msg_window, str_msg, idinfo.base
    str1 = '-50.0'
    widget_control, idinfo.time_delay_low_text, set_value = str1
  endif
  if is_valid_str_to_be_number(str2) ne 1 then begin
    error_num = 351
    str_msg = bes_analyser_error_list(error_num)
    create_err_msg_window, str_msg, idinfo.base
    str2 = '50.0'
    widget_control, idinfo.time_delay_high_text, set_value = str2
  endif
  info.dens_spa_temp_corr_window_data.time_delay_low = float(str1)
  info.dens_spa_temp_corr_window_data.time_delay_high = float(str2)

; get calc_fcn_time
  str = widget_info(idinfo.calc_fcn_time_combo, /combobox_gettext)
  str = str[0]
  widget_control, idinfo.calc_fcn_time_combo, get_value = compare_str
  inx = where(compare_str eq str, count)
  if count le 0 then begin
    inx = 0
    widget_control, idinfo.calc_fcn_time_combo, set_combobox_select = inx
  endif
  info.dens_spa_temp_corr_window_data.calc_fcn_time = inx

; get calc_correlation
  info.dens_spa_temp_corr_window_data.calc_correlation = widget_info(idinfo.calc_correlation_button, /button_set)

; get calc_covariance
  info.dens_spa_temp_corr_window_data.calc_covariance = widget_info(idinfo.calc_covariance_button, /button_set)

; get convert_temp_to_spa
  info.dens_spa_temp_corr_window_data.convert_temp_to_spa = widget_info(idinfo.convert_temp_to_spa_button, /button_set)

; get use_cxrs_data
  info.dens_spa_temp_corr_window_data.use_cxrs_data = widget_info(idinfo.use_cxrs_data_button, /button_set)

; get use_ss_cxrs
  str = widget_info(idinfo.use_ss_cxrs_combo, /combobox_gettext)
  str = str[0]
  widget_control, idinfo.use_ss_cxrs_combo, get_value = compare_str
  inx = where(compare_str eq str, count)
  if count le 0 then begin
    inx = 0
    widget_control, idinfo.use_ss_cxrs_combo, set_combobox_select = inx
  endif
  info.dens_spa_temp_corr_window_data.use_ss_cxrs = inx

; get manual_vtor
  widget_control, idinfo.manual_vtor_text, get_value = str
  str = str[0]
  if is_valid_str_to_be_number(str) ne 1 then begin
    error_num = 400
    str_msg = bes_analyser_error_list(error_num)
    create_err_msg_window, str_msg, idinfo.base
    str = '50.0'
    widget_control, idinfo.manual_vtor_text, set_value = str
  endif
  info.dens_spa_temp_corr_window_data.manual_vtor = float(str)

; get num_bins_to_average
  widget_control, idinfo.num_bins_to_average_text, get_value = str
  str = str[0]
  if is_valid_str_to_be_number(str) ne 1 then begin
    error_num = 300
    str_msg = bes_analyser_error_list(error_num)
    create_err_msg_window, str_msg, idinfo.base
    str = '10'
    widget_control, idinfo.num_bins_to_average_text, set_value = str
  endif
  if ( (long(str) lt 1) and (info.dens_spa_temp_corr_window_data.calc_fcn_time eq 1) ) then begin
    error_num = 352
    str_msg = bes_analyser_error_list(error_num)
    create_err_msg_window, str_msg, idinfo.base
    str = '10'
    widget_control, idinfo.num_bins_to_average_text, set_value = str
  endif
  info.dens_spa_temp_corr_window_data.num_bins_to_average = long(str)

; get frac_overlap_subwindow
  widget_control, idinfo.frac_overlap_subwindow_slider, get_value = int_pos
  info.dens_spa_temp_corr_window_data.frac_overlap_subwindow = float(int_pos) * 0.1

;get use_hanning_window
  str = widget_info(idinfo.use_hanning_window_combo, /combobox_gettext)
  str = str[0]
  widget_control, idinfo.use_hanning_window_combo, get_value = compare_str
  inx = where(compare_str eq str, count)
  if count le 0 then begin
    inx = 0
    widget_control, idinfo.use_hanning_window_combo, set_combobox_select = inx
  endif
  info.dens_spa_temp_corr_window_data.use_hanning_window = inx

; get remove_large_structure
  str = widget_info(idinfo.remove_large_structure_combo, /combobox_gettext)
  str = str[0]
  widget_control, idinfo.remove_large_structure_combo, get_value = compare_str
  inx = where(str eq compare_str, count)
  if count le 0 then begin
    inx = 0
    widget_control, idinfo.remove_large_structure_combo, set_combobox_select = inx
  endif
  info.dens_spa_temp_corr_window_data.remove_large_structure = inx

; get factor_inc_spa_pts
  widget_control, idinfo.factor_inc_spa_pts_text, get_value = str
  str = str[0]
  if is_valid_str_to_be_number(str) ne 1 then begin
    error_num = 250
    str_msg = bes_analyser_error_list(error_num)
    create_err_msg_window, str_msg, idinfo.base
    str = '10'
    widget_control, idinfo.factor_inc_spa_pts_text, set_value = str
  endif
  if ( (long(str) lt 1) or (long(str) gt 30) ) then begin
    error_num = 251
    str_msg = bes_analyser_error_list(error_num)
    create_err_msg_window, str_msg, idinfo.base
    str = '10'
    widget_control, idinfo.factor_inc_spa_pts_text, set_value = str
  endif
  info.dens_spa_temp_corr_window_data.factor_inc_spa_pts = long(str)


; save the info structure
  widget_control, idinfo.id_main_base, set_uvalue = info

end


;===================================================================================
; This procedure controls the sensitivity of the widgest for bes_dens_psa_temp_corr_window
;===================================================================================
; The function parameters:
;   1) 'idinfo' is a structure that is saved as uvalue under bes_dens_spa_temp_corr_window
;===================================================================================
pro sens_check_bes_dens_spa_temp_corr_window, idinfo

; get calc_fcn_time
  str = widget_info(idinfo.calc_fcn_time_combo, /combobox_gettext)
  str = str[0]
  widget_control, idinfo.calc_fcn_time_combo, get_value = compare_str
  inx = where(compare_str eq str)
  calc_fcn_time = inx	;if 0, then 'at a fixed time'; if 1, then 'as a fcn of time'

; get calc_pol_spa: if 1, then poloidal direction; if 0, then radial direction 
  calc_pol_spa = widget_info(idinfo.calc_pol_spa_button, /button_set)

; get convert_temp_to_spa
  convert_temp_to_spa = widget_info(idinfo.convert_temp_to_spa_button, /button_set)

; get use_cxrs
  use_cxrs = widget_info(idinfo.use_cxrs_data_button, /button_set)

  if calc_fcn_time eq 1 then begin
    widget_control, idinfo.movie_button, sensitive = 1
    widget_control, idinfo.num_bins_to_average_text, sensitive = 1
  endif else begin
    widget_control, idinfo.movie_button, sensitive = 0
    widget_control, idinfo.num_bins_to_average_text, sensitive = 0
  endelse

  if ( (calc_pol_spa eq 1) and (convert_temp_to_spa eq 1) and (calc_fcn_time eq 1) ) then $
    widget_control, idinfo.plot_pitch_button, sensitive = 1 $
  else $
    widget_control, idinfo.plot_pitch_button, sensitive = 0

  if calc_pol_spa eq 1 then begin
    widget_control, idinfo.convert_temp_to_spa_button, sensitive = 1
    if convert_temp_to_spa eq 1 then begin
      widget_control, idinfo.use_cxrs_data_button, sensitive = 1
      if use_cxrs eq 1 then begin
        widget_control, idinfo.use_ss_cxrs_combo, sensitive = 1
        widget_control, idinfo.plot_cxrs_button, sensitive = 1
        widget_control, idinfo.manual_vtor_text, sensitive = 0
      endif else begin
        widget_control, idinfo.use_ss_cxrs_combo, sensitive = 0
        widget_control, idinfo.plot_cxrs_button, sensitive = 0
        widget_control, idinfo.manual_vtor_text, sensitive = 1
      endelse
    endif else begin
      widget_control, idinfo.use_cxrs_data_button, sensitive = 0
      widget_control, idinfo.use_ss_cxrs_combo, sensitive = 0
      widget_control, idinfo.plot_cxrs_button, sensitive = 0
      widget_control, idinfo.manual_vtor_text, sensitive = 0
    endelse
  endif else begin
    widget_control, idinfo.convert_temp_to_spa_button, sensitive = 0
    widget_control, idinfo.use_cxrs_data_button, sensitive = 0
    widget_control, idinfo.use_ss_cxrs_combo, sensitive = 0
    widget_control, idinfo.plot_cxrs_button, sensitive = 0
    widget_control, idinfo.manual_vtor_text, sensitive = 0
  endelse

end


;===================================================================================
; This procedure controls events generated by bes_dens_spa_temp_corr_window
;===================================================================================
; The function parameters:
;   1) 'event' is generated by the system and passed to the procedure 
;        for control purpose
;===================================================================================
pro bes_dens_spa_temp_corr_window_event, event

; get the user value
  widget_control, event.top, get_uvalue = idinfo

; check if called due to kill_event
  if ( (tag_names(event, /structure_name) eq 'WIDGET_KILL_REQUEST') or $ 
       (event.id eq idinfo.close_button) ) then begin
  ; update the fields
    update_bes_dens_spa_temp_corr_window, idinfo

  ; re-enable the ACTION buttons
    widget_control, idinfo.id_main_base, get_uvalue = info

    widget_control, info.id.main_window.basic_anal_action_button, sensitive = 1
    widget_control, info.id.main_window.dens_advanced_anal_action_button, sensitive = 1
    widget_control, info.id.main_window.vel_advanced_anal_action_button, sensitive = 1

  ; kill the window
    kill_dens_spa_temp_corr_window, idinfo.base
    return
  endif

; control the senstivity of widgets
  sens_check_bes_dens_spa_temp_corr_window, idinfo

; called due to BES_Ch_button
  for i = 0, 31 do begin
    if event.id eq idinfo.BES_Ch_button[i] then begin
      button_set = widget_info(idinfo.BES_Ch_button[i], /button_set)
      RAD_pos = i mod 8
      POL_pos = i/8
      bes_ch_button_ctrl, RAD_pos, POL_pos, button_set, $
                          idinfo.BES_Ch_button, idinfo.POL_Ch_button, idinfo.RAD_Ch_button
      return
    endif
  endfor

; called due to POL_Ch_button
  for i = 0, 3 do begin
    if event.id eq idinfo.POL_Ch_button[i] then begin
      button_set = widget_info(idinfo.POL_Ch_button[i], /button_set)
      bes_pol_ch_button_ctrl, i, button_set, $
                              idinfo.BES_Ch_button, idinfo.POL_Ch_button, idinfo.RAD_Ch_button
      return
    endif
  endfor

; called due to RAD_Ch_button
  for i = 0, 7 do begin
    if event.id eq idinfo.RAD_Ch_button[i] then begin
      button_set = widget_info(idinfo.RAD_Ch_button[i], /button_set)
      bes_rad_ch_button_ctrl, i, button_set, $
                              idinfo.BES_Ch_button, idinfo.POL_Ch_button, idinfo.RAD_Ch_button
      return
    endif
  endfor

; event due to frac_overlap_subwindow_slider
  if event.id eq idinfo.frac_overlap_subwindow_slider then begin
    widget_control, idinfo.frac_overlap_subwindow_slider, get_value = int_pos
    str = string(int_pos*0.1, format='(f0.1)')
    widget_control, idinfo.frac_overlap_subwindow_label, set_value = str
    return
  endif

; event due to plot_button or movie_button
  if ( (event.id eq idinfo.plot_button) or (event.id eq idinfo.movie_button) ) then begin
  ; check selected BES channel
    pol_dir = widget_info(idinfo.calc_pol_spa_button, /button_set)
    check_result = check_bes_ch_pol_rad_direction(pol_dir, idinfo.BES_Ch_button)
    if check_result ne 0 then begin
      errmsg = bes_analyser_error_list(check_result)
      create_err_msg_window, errmsg, idinfo.base
      return
    endif

  ; show hour glass
    widget_control, /hourglass

  ; disable the buttons
    widget_control, idinfo.plot_button, sensitive = 0
    widget_control, idinfo.movie_button, sensitive = 0
    widget_control, idinfo.plot_pitch_button, sensitive = 0
    widget_control, idinfo.plot_cxrs_button, sensitive = 0
    widget_control, idinfo.save_options_button, sensitive = 0
    widget_control, idinfo.load_options_button, sensitive = 0
    widget_control, idinfo.help_button, sensitive = 0
    widget_control, idinfo.close_button, sensitive = 0

  ; update the fields
    update_bes_dens_spa_temp_corr_window, idinfo

  ; plot the data
    if event.id eq idinfo.plot_button then $
      result = ctrl_plot_dens_spa_temp_corr(idinfo) $
    else $
      result = ctrl_plot_dens_spa_temp_corr(idinfo, /movie)

    if result.erc ne 0 then begin
      create_err_msg_window, result.errmsg, idinfo.base
    endif

  ; enable the buttons
    widget_control, idinfo.plot_button, sensitive = 1
    widget_control, idinfo.movie_button, sensitive = 1
    widget_control, idinfo.plot_pitch_button, sensitive = 1
    widget_control, idinfo.plot_cxrs_button, sensitive = 1
    widget_control, idinfo.save_options_button, sensitive = 1
    widget_control, idinfo.load_options_button, sensitive = 1
    widget_control, idinfo.help_button, sensitive = 1
    widget_control, idinfo.close_button, sensitive = 1

  ; control the senstivity of widgets
    sens_check_bes_dens_spa_temp_corr_window, idinfo

    return
  endif

; event due to plot_pitch_button
  if event.id eq idinfo.plot_pitch_button then begin


    return
  endif

; event due to plot_cxrs_button
  if event.id eq idinfo.plot_cxrs_button then begin


    return
  endif

; event due to help_button
  if event.id eq idinfo.help_button then begin
    filename = 'BES_Analyser_Dens_Spatio_Temp_Corr_Explain.pdf'
    help_result = open_help_file(filename)
    if help_result.erc ne 0 then begin
      create_err_msg_window, help_result.errmsg, idinfo.base
    endif
    return
  endif

; called due to load_options_button
  if event.id eq idinfo.load_options_button then begin
  ; set the file extension
    file_extension = '.dens_stcorr'
  ; get the filename
    filename = create_load_options_window(idinfo.id_main_base, file_extension)
  ; load the options
    if filename ne '' then begin
      result = load_options_info(idinfo.id_main_base, idinfo, filename, file_extension)
      if result ne 0 then begin
        errmsg = bes_analyser_error_list(result)
        create_err_msg_window, errmsg, idinfo.base
      endif
    endif

    return
  endif

; called due to save_options_button
  if event.id eq idinfo.save_options_button then begin
  ; set the file extension
    file_extension = '.dens_stcorr'
  ; update the fields
    update_bes_dens_spa_temp_corr_window, idinfo
  ; create the window
    create_save_options_window, idinfo.id_main_base, file_extension

    return
  endif

end



;===================================================================================
; This procedure updates the info field for bes_dens_spa_spa_corr_window_event
;===================================================================================
; The function parameters:
;   1) 'idinfo' is a structure that is saved as uvalue under bes_dens_spa_spa_corr_window_event
;===================================================================================
pro update_bes_dens_spa_spa_corr_window_event, idinfo

; get the info structure
  widget_control, idinfo.id_main_base, get_uvalue = info

; get the calc_in_IDL
  info.dens_spa_spa_corr_window_data.calc_in_IDL = widget_info(idinfo.calc_in_IDL_button, /button_set)

; get the calc_in_CUDA
  info.dens_spa_spa_corr_window_data.calc_in_CUDA = widget_info(idinfo.calc_in_CUDA_button, /button_set)

; get the calc_spa_avg_NO
  info.dens_spa_spa_corr_window_data.calc_spa_avg_NO = widget_info(idinfo.calc_spa_avg_NO_button, /button_set)

; get the calc_spa_avg_YES
  info.dens_spa_spa_corr_window_data.calc_spa_avg_YES = widget_info(idinfo.calc_spa_avg_YES_button, /button_set)

; get the BES_ch_sel
  nch = n_elements(info.dens_spa_spa_corr_window_data.BES_ch_sel)
  for i = 0, nch - 1 do $
    info.dens_spa_spa_corr_window_data.BES_ch_sel[i] = widget_info(idinfo.BES_ch_sel_button[i], /button_set)

; get frequency filtering range
  widget_control, idinfo.freq_filter_low_text, get_value = str1
  str1 = str1[0]
  widget_control, idinfo.freq_filter_high_text, get_value = str2
  str2 = str2[0]
  if is_valid_str_to_be_number(str1) ne 1 then begin
    error_num = 252
    str_msg = bes_analyser_error_list(error_num)
    create_err_msg_window, str_msg, idinfo.base
    str1 = '0.0'
    widget_control, idinfo.freq_filter_low_text, set_value = str1
  endif
  if is_valid_str_to_be_number(str2) ne 1 then begin
    error_num = 253
    str_msg = bes_analyser_error_list(error_num)
    create_err_msg_window, str_msg, idinfo.base
    str2 = '1000.0'
    widget_control, idinfo.freq_filter_high_text, set_value = str2
  endif
  info.dens_spa_spa_corr_window_data.freq_filter_low = float(str1)
  info.dens_spa_spa_corr_window_data.freq_filter_high = float(str2)

; get time-delay range
  widget_control, idinfo.time_delay_low_text, get_value = str1
  str1 = str1[0]
  widget_control, idinfo.time_delay_high_text, get_value = str2
  str2 = str2[0]
  if is_valid_str_to_be_number(str1) ne 1 then begin
    error_num = 350
    str_msg = bes_analyser_error_list(error_num)
    create_err_msg_window, str_msg, idinfo.base
    str1 = '-50.0'
    widget_control, idinfo.time_delay_low_text, set_value = str1
  endif
  if is_valid_str_to_be_number(str2) ne 1 then begin
    error_num = 351
    str_msg = bes_analyser_error_list(error_num)
    create_err_msg_window, str_msg, idinfo.base
    str2 = '50.0'
    widget_control, idinfo.time_delay_high_text, set_value = str2
  endif
  info.dens_spa_spa_corr_window_data.time_delay_low = float(str1)
  info.dens_spa_spa_corr_window_data.time_delay_high = float(str2)

; get the calc_covariance
  info.dens_spa_spa_corr_window_data.calc_covariance = widget_info(idinfo.calc_covariance_button, /button_set)

; get the calc_correlation
  info.dens_spa_spa_corr_window_data.calc_correlation = widget_info(idinfo.calc_correlation_button, /button_set)

; get frac_overlap_subwindow
  widget_control, idinfo.frac_overlap_subwindow_slider, get_value = int_pos
  info.dens_spa_spa_corr_window_data.frac_overlap_subwindow = float(int_pos) * 0.1

;get use_hanning_window
  str = widget_info(idinfo.use_hanning_window_combo, /combobox_gettext)
  str = str[0]
  widget_control, idinfo.use_hanning_window_combo, get_value = compare_str
  inx = where(compare_str eq str, count)
  if count le 0 then begin
    inx = 0
    widget_control, idinfo.use_hanning_window_combo, set_combobox_select = inx
  endif
  info.dens_spa_spa_corr_window_data.use_hanning_window = inx

; get remove_large_structure
  str = widget_info(idinfo.remove_large_structure_combo, /combobox_gettext)
  str = str[0]
  widget_control, idinfo.remove_large_structure_combo, get_value = compare_str
  inx = where(str eq compare_str, count)
  if count le 0 then begin
    inx = 0
    widget_control, idinfo.remove_large_structure_combo, set_combobox_select = inx
  endif
  info.dens_spa_spa_corr_window_data.remove_large_structure = inx


; save the info structure
  widget_control, idinfo.id_main_base, set_uvalue = info

end


;===================================================================================
; This procedure controls events generated by bes_dens_spa_spa_corr_window_event
;===================================================================================
; The function parameters:
;   1) 'event' is generated by the system and passed to the procedure 
;        for control purpose
;===================================================================================
pro bes_dens_spa_spa_corr_window_event, event

; get the user value
  widget_control, event.top, get_uvalue = idinfo

; check if called due to kill_event
  if ( (tag_names(event, /structure_name) eq 'WIDGET_KILL_REQUEST') or $ 
       (event.id eq idinfo.close_button) ) then begin
  ; update the fields
    update_bes_dens_spa_spa_corr_window_event, idinfo

  ; re-enable the ACTION buttons
    widget_control, idinfo.id_main_base, get_uvalue = info

    widget_control, info.id.main_window.basic_anal_action_button, sensitive = 1
    widget_control, info.id.main_window.dens_advanced_anal_action_button, sensitive = 1
    widget_control, info.id.main_window.vel_advanced_anal_action_button, sensitive = 1

  ; kill the window
    kill_dens_spatio_spatio_corr_window, idinfo.base
    return
  endif

; event due to BES_ch_sel_button
  inx = where(event.id eq idinfo.BES_ch_sel_button, count)
  if count gt 0 then begin
    make_bes_ch_button_exclusive, inx, idinfo.BES_ch_sel_button
 
    return
  endif

; called due to calc_spa_avg_NO_button or calc_spa_avg_YES_button
  if ( (event.id eq idinfo.calc_spa_avg_NO_button) or (event.id eq idinfo.calc_spa_avg_YES_button) ) then begin
    NO_select = widget_info(idinfo.calc_spa_avg_NO_button, /button_set)
    YES_select = widget_info(idinfo.calc_spa_avg_YES_button, /button_set)
    for i = 0, n_elements(idinfo.BES_ch_sel_button) - 1 do $
      widget_control, idinfo.BES_ch_sel_button[i], sensitive = NO_select
    widget_control, idinfo.compare_coarr_button, sensitive = YES_select

    return
  endif 

; event due to frac_overlap_subwindow_slider
  if event.id eq idinfo.frac_overlap_subwindow_slider then begin
    widget_control, idinfo.frac_overlap_subwindow_slider, get_value = int_pos
    str = string(int_pos*0.1, format='(f0.1)')
    widget_control, idinfo.frac_overlap_subwindow_label, set_value = str

    return
  endif

; called due to load_options_button
  if event.id eq idinfo.load_options_button then begin
  ; set the file extension
    file_extension = '.dens_sscorr'
  ; get the filename
    filename = create_load_options_window(idinfo.id_main_base, file_extension)
  ; load the options
    if filename ne '' then begin
      result = load_options_info(idinfo.id_main_base, idinfo, filename, file_extension)
      if result ne 0 then begin
        errmsg = bes_analyser_error_list(result)
        create_err_msg_window, errmsg, idinfo.base
      endif
    endif

    return
  endif

; called due to save_options_button
  if event.id eq idinfo.save_options_button then begin
  ; set the file extension
    file_extension = '.dens_sscorr'
  ; update the fields
    update_bes_dens_spa_spa_corr_window_event, idinfo
  ; create the window
    create_save_options_window, idinfo.id_main_base, file_extension

    return
  endif

; event due to help_button
  if event.id eq idinfo.help_button then begin
;    filename = 'BES_Analyser_Dens_Spatio_Temp_Corr_Explain.pdf'
;    help_result = open_help_file(filename)
;    if help_result.erc ne 0 then begin
;      create_err_msg_window, help_result.errmsg, idinfo.base
;    endif
;    return
  endif


; event due to plot_button or compare_coarr_button
  if ( (event.id eq idinfo.plot_button) or (event.id eq idinfo.compare_coarr_button) ) then begin
  ; show hour glass
    widget_control, /hourglass

  ; disable the buttons
    widget_control, idinfo.plot_button, sensitive = 0
    widget_control, idinfo.compare_coarr_button, sensitive = 0
    widget_control, idinfo.save_options_button, sensitive = 0
    widget_control, idinfo.load_options_button, sensitive = 0
    widget_control, idinfo.help_button, sensitive = 0
    widget_control, idinfo.close_button, sensitive = 0

  ; update the fields
    update_bes_dens_spa_spa_corr_window_event, idinfo

  ; plot the data
    if event.id eq idinfo.compare_coarr_button then compare_coarr = 1 else compare_coarr = 0
    result = ctrl_plot_dens_spa_spa_corr(idinfo, compare_coarr)

    if result.erc ne 0 then begin
      create_err_msg_window, result.errmsg, idinfo.base
    endif

  ; enable the buttons
    widget_control, idinfo.plot_button, sensitive = 1
    widget_control, idinfo.compare_coarr_button, sensitive = 1
    widget_control, idinfo.save_options_button, sensitive = 1
    widget_control, idinfo.load_options_button, sensitive = 1
    widget_control, idinfo.help_button, sensitive = 1
    widget_control, idinfo.close_button, sensitive = 1
    return
  endif

end



;===================================================================================
; This procedure updates the info field for bes_vel_evol_window
;===================================================================================
; The function parameters:
;   1) 'idinfo' is a structure that is saved as uvalue under bes_vel_evol_window
;===================================================================================
pro update_bes_vel_evol_window, idinfo

; get the info structure
  widget_control, idinfo.id_main_base, get_uvalue = info

; get the calc_in_IDL
  info.vel_time_evol_window_data.calc_in_IDL = widget_info(idinfo.calc_in_IDL_button, /button_set)

; get the calc_in_CUDA
  info.vel_time_evol_window_data.calc_in_CUDA = widget_info(idinfo.calc_in_CUDA_button, /button_set)

; get the calc_pol_spa
  info.vel_time_evol_window_data.calc_pol_vel = widget_info(idinfo.calc_pol_vel_button, /button_set)

; get the calc_rad_spa
  info.vel_time_evol_window_data.calc_rad_vel = widget_info(idinfo.calc_rad_vel_button, /button_set)

; get the BES_ch_sel
  nch = n_elements(info.vel_time_evol_window_data.BES_ch_sel)
  for i = 0, nch - 1 do $
    info.vel_time_evol_window_data.BES_ch_sel[i] = widget_info(idinfo.BES_Ch_button[i], /button_set)

; get the BES_RAD_ch_sel
  nch = n_elements(info.vel_time_evol_window_data.BES_RAD_ch_sel)
  for i = 0, nch - 1 do $
    info.vel_time_evol_window_data.BES_RAD_ch_sel[i] = widget_info(idinfo.RAD_Ch_button[i], /button_set)

; get the BES_POL_ch_sel
  nch = n_elements(info.vel_time_evol_window_data.BES_POL_ch_sel)
  for i = 0, nch - 1 do $
    info.vel_time_evol_window_data.BES_POL_ch_sel[i] = widget_info(idinfo.POL_Ch_button[i], /button_set)

; get frequency filtering range
  widget_control, idinfo.freq_filter_low_text, get_value = str1
  str1 = str1[0]
  widget_control, idinfo.freq_filter_high_text, get_value = str2
  str2 = str2[0]
  if is_valid_str_to_be_number(str1) ne 1 then begin
    error_num = 252
    str_msg = bes_analyser_error_list(error_num)
    create_err_msg_window, str_msg, idinfo.base
    str1 = '0.0'
    widget_control, idinfo.freq_filter_low_text, set_value = str1
  endif
  if is_valid_str_to_be_number(str2) ne 1 then begin
    error_num = 253
    str_msg = bes_analyser_error_list(error_num)
    create_err_msg_window, str_msg, idinfo.base
    str2 = '1000.0'
    widget_control, idinfo.freq_filter_high_text, set_value = str2
  endif
  info.vel_time_evol_window_data.freq_filter_low = float(str1)
  info.vel_time_evol_window_data.freq_filter_high = float(str2)

; get the convert_to_tor_vel
  info.vel_time_evol_window_data.convert_to_tor_vel = widget_info(idinfo.convert_to_tor_vel_button, /button_set)

; get the compare_cxrs_ss
  info.vel_time_evol_window_data.compare_cxrs_ss = widget_info(idinfo.compare_cxrs_ss_button, /button_set)

; get the compare_cxrs_sw
  info.vel_time_evol_window_data.compare_cxrs_sw = widget_info(idinfo.compare_cxrs_sw_button, /button_set)

; get time-delay range
  widget_control, idinfo.time_delay_low_text, get_value = str1
  str1 = str1[0]
  widget_control, idinfo.time_delay_high_text, get_value = str2
  str2 = str2[0]
  if is_valid_str_to_be_number(str1) ne 1 then begin
    error_num = 450
    str_msg = bes_analyser_error_list(error_num)
    create_err_msg_window, str_msg, idinfo.base
    str1 = '-30.0'
    widget_control, idinfo.time_delay_low_text, set_value = str1
  endif
  if is_valid_str_to_be_number(str2) ne 1 then begin
    error_num = 451
    str_msg = bes_analyser_error_list(error_num)
    create_err_msg_window, str_msg, idinfo.base
    str2 = '30.0'
    widget_control, idinfo.time_delay_high_text, set_value = str2
  endif
  info.vel_time_evol_window_data.time_delay_low = float(str1)
  info.vel_time_evol_window_data.time_delay_high = float(str2)

; get num_bins_to_average
  widget_control, idinfo.num_bins_to_average_text, get_value = str
  str = str[0]
  if is_valid_str_to_be_number(str) ne 1 then begin
    error_num = 452
    str_msg = bes_analyser_error_list(error_num)
    create_err_msg_window, str_msg, idinfo.base
    str = '300'
    widget_control, idinfo.num_bins_to_average_text, set_value = str
  endif
  if (long(str) lt 1) then begin
    error_num = 452
    str_msg = bes_analyser_error_list(error_num)
    create_err_msg_window, str_msg, idinfo.base
    str = '300'
    widget_control, idinfo.num_bins_to_average_text, set_value = str
  endif
  info.vel_time_evol_window_data.num_bins_to_average = long(str)

; get frac_overlap_subwindow
  widget_control, idinfo.frac_overlap_subwindow_slider, get_value = int_pos
  info.vel_time_evol_window_data.frac_overlap_subwindow = float(int_pos) * 0.1

;get use_hanning_window
  str = widget_info(idinfo.use_hanning_window_combo, /combobox_gettext)
  str = str[0]
  widget_control, idinfo.use_hanning_window_combo, get_value = compare_str
  inx = where(compare_str eq str, count)
  if count le 0 then begin
    inx = 0
    widget_control, idinfo.use_hanning_window_combo, set_combobox_select = inx
  endif
  info.vel_time_evol_window_data.use_hanning_window = inx

; get remove_large_structure
  str = widget_info(idinfo.remove_large_structure_combo, /combobox_gettext)
  str = str[0]
  widget_control, idinfo.remove_large_structure_combo, get_value = compare_str
  inx = where(str eq compare_str, count)
  if count le 0 then begin
    inx = 0
    widget_control, idinfo.remove_large_structure_combo, set_combobox_select = inx
  endif
  info.vel_time_evol_window_data.remove_large_structure = inx

; get apply_median_filter
  info.vel_time_evol_window_data.apply_median_filter = widget_info(idinfo.apply_median_filter_button, /button_set)

; get median_filter_width
  widget_control, idinfo.median_filter_width_text, get_value = str
  str = str[0]
  if is_valid_str_to_be_number(str) ne 1 then begin
    error_num = 456
    str_msg = bes_analyser_error_list(error_num)
    create_err_msg_window, str_msg, idinfo.base
    str = '3'
    widget_control, idinfo.median_filter_width_text, set_value = str
  endif
  if (long(str) lt 3) then begin
    error_num = 456
    str_msg = bes_analyser_error_list(error_num)
    create_err_msg_window, str_msg, idinfo.base
    str = '3'
    widget_control, idinfo.median_filter_width_text, set_value = str
  endif
  info.vel_time_evol_window_data.median_filter_width = long(str)

; get apply_field_method
  info.vel_time_evol_window_data.apply_field_method = widget_info(idinfo.apply_field_method_button, /button_set)

; get num_time_pts_field_method
  widget_control, idinfo.num_time_pts_field_method_text, get_value = str
  str = str[0]
  if is_valid_str_to_be_number(str) ne 1 then begin
    error_num = 457
    str_msg = bes_analyser_error_list(error_num)
    create_err_msg_window, str_msg, idinfo.base
    str = '50'
    widget_control, idinfo.num_time_pts_field_method_text, set_value = str
  endif
  if (long(str) lt 3) then begin
    error_num = 457
    str_msg = bes_analyser_error_list(error_num)
    create_err_msg_window, str_msg, idinfo.base
    str = '50'
    widget_control, idinfo.num_time_pts_field_method_text, set_value = str
  endif
  info.vel_time_evol_window_data.num_time_pts_field_method = long(str)

; get allowed_mult_sd
  widget_control, idinfo.allowed_mult_sd_text, get_value = str
  str = str[0]
  if is_valid_str_to_be_number(str) ne 1 then begin
    error_num = 458
    str_msg = bes_analyser_error_list(error_num)
    create_err_msg_window, str_msg, idinfo.base
    str = '3.0'
    widget_control, idinfo.allowed_mult_sd_text, set_value = str
  endif
  if (float(str) lt 0.1) then begin
    error_num = 458
    str_msg = bes_analyser_error_list(error_num)
    create_err_msg_window, str_msg, idinfo.base
    str = '3.0'
    widget_control, idinfo.allowed_mult_sd_text, set_value = str
  endif
  info.vel_time_evol_window_data.allowed_mult_sd = float(str)


; save the info structure
  widget_control, idinfo.id_main_base, set_uvalue = info

end


;===================================================================================
; This procedure controls events generated by bes_vel_evol_window
;===================================================================================
; The function parameters:
;   1) 'event' is generated by the system and passed to the procedure 
;        for control purpose
;===================================================================================
pro bes_vel_evol_window_event, event

; get the user value
  widget_control, event.top, get_uvalue = idinfo

; check if called due to kill_event
  if ( (tag_names(event, /structure_name) eq 'WIDGET_KILL_REQUEST') or $ 
       (event.id eq idinfo.close_button) ) then begin
  ; update the fields
    update_bes_vel_evol_window, idinfo

  ; re-enable the ACTION buttons
    widget_control, idinfo.id_main_base, get_uvalue = info

    widget_control, info.id.main_window.basic_anal_action_button, sensitive = 1
    widget_control, info.id.main_window.dens_advanced_anal_action_button, sensitive = 1
    widget_control, info.id.main_window.vel_advanced_anal_action_button, sensitive = 1

  ; kill the window
    kill_vel_evol_window, idinfo.base

    return
  endif

; called due to calc_pol_vel_button
  if event.id eq idinfo.calc_pol_vel_button then begin
    button_set = widget_info(idinfo.calc_pol_vel_button, /button_set)
    widget_control, idinfo.convert_to_tor_vel_button, sensitive = button_set
    widget_control, idinfo.compare_cxrs_ss_button, sensitive = button_set
    widget_control, idinfo.compare_cxrs_sw_button, sensitive = button_set
    if button_set eq 1 then begin
      button_set = widget_info(idinfo.convert_to_tor_vel_button, /button_set)
      widget_control, idinfo.compare_cxrs_ss_button, sensitive = button_set
      widget_control, idinfo.compare_cxrs_sw_button, sensitive = button_set
    endif

    return
  endif

; called due to calc_rad_vel_button
  if event.id eq idinfo.calc_rad_vel_button then begin
    button_set = widget_info(idinfo.calc_pol_vel_button, /button_set)
    widget_control, idinfo.convert_to_tor_vel_button, sensitive = button_set
    widget_control, idinfo.compare_cxrs_ss_button, sensitive = button_set
    widget_control, idinfo.compare_cxrs_sw_button, sensitive = button_set
    if button_set eq 1 then begin
      button_set = widget_info(idinfo.convert_to_tor_vel_button, /button_set)
      widget_control, idinfo.compare_cxrs_ss_button, sensitive = button_set
      widget_control, idinfo.compare_cxrs_sw_button, sensitive = button_set
    endif

    return
  endif

; called due to BES_Ch_button
  for i = 0, 31 do begin
    if event.id eq idinfo.BES_Ch_button[i] then begin
      button_set = widget_info(idinfo.BES_Ch_button[i], /button_set)
      RAD_pos = i mod 8
      POL_pos = i/8
      bes_ch_button_ctrl, RAD_pos, POL_pos, button_set, $
                          idinfo.BES_Ch_button, idinfo.POL_Ch_button, idinfo.RAD_Ch_button
      return
    endif
  endfor

; called due to POL_Ch_button
  for i = 0, 3 do begin
    if event.id eq idinfo.POL_Ch_button[i] then begin
      button_set = widget_info(idinfo.POL_Ch_button[i], /button_set)
      bes_pol_ch_button_ctrl, i, button_set, $
                              idinfo.BES_Ch_button, idinfo.POL_Ch_button, idinfo.RAD_Ch_button
      return
    endif
  endfor

; called due to RAD_Ch_button
  for i = 0, 7 do begin
    if event.id eq idinfo.RAD_Ch_button[i] then begin
      button_set = widget_info(idinfo.RAD_Ch_button[i], /button_set)
      bes_rad_ch_button_ctrl, i, button_set, $
                              idinfo.BES_Ch_button, idinfo.POL_Ch_button, idinfo.RAD_Ch_button
      return
    endif
  endfor

; called due to convert_to_tor_vel_button
  if event.id eq idinfo.convert_to_tor_vel_button then begin
    button_set = widget_info(idinfo.convert_to_tor_vel_button, /button_set)
    widget_control, idinfo.compare_cxrs_ss_button, sensitive = button_set
    widget_control, idinfo.compare_cxrs_sw_button, sensitive = button_set
    return
  endif


; event due to frac_overlap_subwindow_slider
  if event.id eq idinfo.frac_overlap_subwindow_slider then begin
    widget_control, idinfo.frac_overlap_subwindow_slider, get_value = int_pos
    str = string(int_pos*0.1, format='(f0.1)')
    widget_control, idinfo.frac_overlap_subwindow_label, set_value = str
    return
  endif

; event due to apply_median_filter_button
  if event.id eq idinfo.apply_median_filter_button then begin
    apply_median_filter_button_set = widget_info(idinfo.apply_median_filter_button, /button_set)
    widget_control, idinfo.median_filter_width_text, sensitive = apply_median_filter_button_set
    widget_control, idinfo.apply_field_method_button, sensitive = apply_median_filter_button_set
    apply_field_method_button_set = widget_info(idinfo.apply_field_method_button, /button_set)
    if ( (apply_median_filter_button_set eq 1) and (apply_field_method_button_set eq 1) ) then begin
      widget_control, idinfo.num_time_pts_field_method_text, sensitive = 1
      widget_control, idinfo.allowed_mult_sd_text, sensitive = 1
    endif else begin
      widget_control, idinfo.num_time_pts_field_method_text, sensitive = 0
      widget_control, idinfo.allowed_mult_sd_text, sensitive = 0
    endelse

    return
  endif

; event due to apply_field_method_button
  if event.id eq idinfo.apply_field_method_button then begin
    widget_control, idinfo.num_time_pts_field_method_text, sensitive = widget_info(idinfo.apply_field_method_button, /button_set)
    widget_control, idinfo.allowed_mult_sd_text, sensitive = widget_info(idinfo.apply_field_method_button, /button_set)

    return
  endif


; event due to plot_button or oplot_button
  if ( (event.id eq idinfo.plot_button) or (event.id eq idinfo.oplot_button) ) then begin
  ; check selected BES channel
    pol_dir = widget_info(idinfo.calc_pol_vel_button, /button_set)
    check_result = check_bes_ch_pol_rad_direction(pol_dir, idinfo.BES_Ch_button)
    if check_result ne 0 then begin
      errmsg = bes_analyser_error_list(check_result)
      create_err_msg_window, errmsg, idinfo.base
      return
    endif

  ; show hour glass
    widget_control, /hourglass

  ; disable the buttons
    widget_control, idinfo.plot_button, sensitive = 0
    widget_control, idinfo.oplot_button, sensitive = 0
    widget_control, idinfo.save_options_button, sensitive = 0
    widget_control, idinfo.load_options_button, sensitive = 0
    widget_control, idinfo.help_button, sensitive = 0
    widget_control, idinfo.close_button, sensitive = 0

  ; update the fields
    update_bes_vel_evol_window, idinfo

  ; plot the data
    if event.id eq idinfo.plot_button then $
      result = ctrl_plot_vel_evol(idinfo) $
    else $
      result = ctrl_plot_vel_evol(idinfo, /overplot)

    if result.erc ne 0 then begin
      create_err_msg_window, result.errmsg, idinfo.base
    endif

  ; enable the buttons
    widget_control, idinfo.plot_button, sensitive = 1
    widget_control, idinfo.oplot_button, sensitive = 1
    widget_control, idinfo.save_options_button, sensitive = 1
    widget_control, idinfo.load_options_button, sensitive = 1
    widget_control, idinfo.help_button, sensitive = 1
    widget_control, idinfo.close_button, sensitive = 1

    return
  endif


; event due to help_button
  if event.id eq idinfo.help_button then begin
;    filename = 'BES_Analyser_Dens_Spatio_Temp_Corr_Explain.pdf'
;    help_result = open_help_file(filename)
;    if help_result.erc ne 0 then begin
;      create_err_msg_window, help_result.errmsg, idinfo.base
;    endif
    return
  endif

; called due to load_options_button
  if event.id eq idinfo.load_options_button then begin
  ; set the file extension
    file_extension = '.vel_evol'
  ; get the filename
    filename = create_load_options_window(idinfo.id_main_base, file_extension)
  ; load the options
    if filename ne '' then begin
      result = load_options_info(idinfo.id_main_base, idinfo, filename, file_extension)
      if result ne 0 then begin
        errmsg = bes_analyser_error_list(result)
        create_err_msg_window, errmsg, idinfo.base
      endif
    endif

    return
  endif

; called due to save_options_button
  if event.id eq idinfo.save_options_button then begin
  ; set the file extension
    file_extension = '.vel_evol'
  ; update the fields
    update_bes_vel_evol_window, idinfo
  ; create the window
    create_save_options_window, idinfo.id_main_base, file_extension

    return
  endif


end


;===================================================================================
; This procedure updates the info field for bes_vel_spec_window
;===================================================================================
; The function parameters:
;   1) 'idinfo' is a structure that is saved as uvalue under bes_vel_spec_window
;===================================================================================
pro update_bes_vel_spec_window, idinfo

; get the info structure
  widget_control, idinfo.id_main_base, get_uvalue = info

; get the calc_in_IDL
  info.vel_spec_window_data.calc_in_IDL = widget_info(idinfo.calc_in_IDL_button, /button_set)

; get the calc_in_CUDA
  info.vel_spec_window_data.calc_in_CUDA = widget_info(idinfo.calc_in_CUDA_button, /button_set)

; get the calc_pol_spa
  info.vel_spec_window_data.calc_pol_vel = widget_info(idinfo.calc_pol_vel_button, /button_set)

; get the calc_rad_spa
  info.vel_spec_window_data.calc_rad_vel = widget_info(idinfo.calc_rad_vel_button, /button_set)

; get the BES_ch_sel
  nch = n_elements(info.vel_spec_window_data.BES_ch_sel1)
  for i = 0, nch - 1 do $
    info.vel_spec_window_data.BES_ch_sel1[i] = widget_info(idinfo.BES_Ch_button1[i], /button_set)
  nch = n_elements(info.vel_spec_window_data.BES_ch_sel2)
  for i = 0, nch - 1 do $
    info.vel_spec_window_data.BES_ch_sel2[i] = widget_info(idinfo.BES_Ch_button2[i], /button_set)

; get the BES_RAD_ch_sel
  nch = n_elements(info.vel_spec_window_data.BES_RAD_ch_sel1)
  for i = 0, nch - 1 do $
    info.vel_spec_window_data.BES_RAD_ch_sel1[i] = widget_info(idinfo.RAD_Ch_button1[i], /button_set)
  nch = n_elements(info.vel_spec_window_data.BES_RAD_ch_sel2)
  for i = 0, nch - 1 do $
    info.vel_spec_window_data.BES_RAD_ch_sel2[i] = widget_info(idinfo.RAD_Ch_button2[i], /button_set)

; get the BES_POL_ch_sel
  nch = n_elements(info.vel_spec_window_data.BES_POL_ch_sel1)
  for i = 0, nch - 1 do $
    info.vel_spec_window_data.BES_POL_ch_sel1[i] = widget_info(idinfo.POL_Ch_button1[i], /button_set)
  nch = n_elements(info.vel_spec_window_data.BES_POL_ch_sel2)
  for i = 0, nch - 1 do $
    info.vel_spec_window_data.BES_POL_ch_sel2[i] = widget_info(idinfo.POL_Ch_button2[i], /button_set)

; get frequency filtering range
  widget_control, idinfo.freq_filter_low_text, get_value = str1
  str1 = str1[0]
  widget_control, idinfo.freq_filter_high_text, get_value = str2
  str2 = str2[0]
  if is_valid_str_to_be_number(str1) ne 1 then begin
    error_num = 252
    str_msg = bes_analyser_error_list(error_num)
    create_err_msg_window, str_msg, idinfo.base
    str1 = '0.0'
    widget_control, idinfo.freq_filter_low_text, set_value = str1
  endif
  if is_valid_str_to_be_number(str2) ne 1 then begin
    error_num = 253
    str_msg = bes_analyser_error_list(error_num)
    create_err_msg_window, str_msg, idinfo.base
    str2 = '1000.0'
    widget_control, idinfo.freq_filter_high_text, set_value = str2
  endif
  info.vel_spec_window_data.freq_filter_low = float(str1)
  info.vel_spec_window_data.freq_filter_high = float(str2)

; get time-delay range
  widget_control, idinfo.time_delay_low_text, get_value = str1
  str1 = str1[0]
  widget_control, idinfo.time_delay_high_text, get_value = str2
  str2 = str2[0]
  if is_valid_str_to_be_number(str1) ne 1 then begin
    error_num = 450
    str_msg = bes_analyser_error_list(error_num)
    create_err_msg_window, str_msg, idinfo.base
    str1 = '-30.0'
    widget_control, idinfo.time_delay_low_text, set_value = str1
  endif
  if is_valid_str_to_be_number(str2) ne 1 then begin
    error_num = 451
    str_msg = bes_analyser_error_list(error_num)
    create_err_msg_window, str_msg, idinfo.base
    str2 = '30.0'
    widget_control, idinfo.time_delay_high_text, set_value = str2
  endif
  info.vel_spec_window_data.time_delay_low = float(str1)
  info.vel_spec_window_data.time_delay_high = float(str2)

; get num_bins_to_average for v(t) calculation
  widget_control, idinfo.num_bins_to_average_vt_text, get_value = str
  str = str[0]
  if is_valid_str_to_be_number(str) ne 1 then begin
    error_num = 500
    str_msg = bes_analyser_error_list(error_num)
    create_err_msg_window, str_msg, idinfo.base
    str = '2'
    widget_control, idinfo.num_bins_to_average_vt_text, set_value = str
  endif
  if (long(str) lt 1) then begin
    error_num = 500
    str_msg = bes_analyser_error_list(error_num)
    create_err_msg_window, str_msg, idinfo.base
    str = '2'
    widget_control, idinfo.num_bins_to_average_vt_text, set_value = str
  endif
  info.vel_spec_window_data.num_bins_to_average_vt = long(str)

; get frac_overlap_subwindow for v(t) calculation
  widget_control, idinfo.frac_overlap_subwindow_vt_slider, get_value = int_pos
  info.vel_spec_window_data.frac_overlap_subwindow_vt = float(int_pos) * 0.1

;get use_hanning_window for v(t) calculation
  str = widget_info(idinfo.use_hanning_window_vt_combo, /combobox_gettext)
  str = str[0]
  widget_control, idinfo.use_hanning_window_vt_combo, get_value = compare_str
  inx = where(compare_str eq str, count)
  if count le 0 then begin
    inx = 0
    widget_control, idinfo.use_hanning_window_vt_combo, set_combobox_select = inx
  endif
  info.vel_spec_window_data.use_hanning_window_vt = inx

; get remove_large_structure
  str = widget_info(idinfo.remove_large_structure_combo, /combobox_gettext)
  str = str[0]
  widget_control, idinfo.remove_large_structure_combo, get_value = compare_str
  inx = where(str eq compare_str, count)
  if count le 0 then begin
    inx = 0
    widget_control, idinfo.remove_large_structure_combo, set_combobox_select = inx
  endif
  info.vel_spec_window_data.remove_large_structure = inx

; get apply_median_filter
  info.vel_spec_window_data.apply_median_filter = widget_info(idinfo.apply_median_filter_button, /button_set)

; get median_filter_width
  widget_control, idinfo.median_filter_width_text, get_value = str
  str = str[0]
  if is_valid_str_to_be_number(str) ne 1 then begin
    error_num = 456
    str_msg = bes_analyser_error_list(error_num)
    create_err_msg_window, str_msg, idinfo.base
    str = '3'
    widget_control, idinfo.median_filter_width_text, set_value = str
  endif
  if (long(str) lt 3) then begin
    error_num = 456
    str_msg = bes_analyser_error_list(error_num)
    create_err_msg_window, str_msg, idinfo.base
    str = '3'
    widget_control, idinfo.median_filter_width_text, set_value = str
  endif
  info.vel_spec_window_data.median_filter_width = long(str)

; get apply_field_method
  info.vel_spec_window_data.apply_field_method = widget_info(idinfo.apply_field_method_button, /button_set)

; get num_time_pts_field_method
  widget_control, idinfo.num_time_pts_field_method_text, get_value = str
  str = str[0]
  if is_valid_str_to_be_number(str) ne 1 then begin
    error_num = 457
    str_msg = bes_analyser_error_list(error_num)
    create_err_msg_window, str_msg, idinfo.base
    str = '50'
    widget_control, idinfo.num_time_pts_field_method_text, set_value = str
  endif
  if (long(str) lt 3) then begin
    error_num = 457
    str_msg = bes_analyser_error_list(error_num)
    create_err_msg_window, str_msg, idinfo.base
    str = '50'
    widget_control, idinfo.num_time_pts_field_method_text, set_value = str
  endif
  info.vel_spec_window_data.num_time_pts_field_method = long(str)

; get allowed_mult_sd
  widget_control, idinfo.allowed_mult_sd_text, get_value = str
  str = str[0]
  if is_valid_str_to_be_number(str) ne 1 then begin
    error_num = 458
    str_msg = bes_analyser_error_list(error_num)
    create_err_msg_window, str_msg, idinfo.base
    str = '3.0'
    widget_control, idinfo.allowed_mult_sd_text, set_value = str
  endif
  if (float(str) lt 0.1) then begin
    error_num = 458
    str_msg = bes_analyser_error_list(error_num)
    create_err_msg_window, str_msg, idinfo.base
    str = '3.0'
    widget_control, idinfo.allowed_mult_sd_text, set_value = str
  endif
  info.vel_spec_window_data.allowed_mult_sd = float(str)


; get calc_spectrogram
  str = widget_info(idinfo.calc_spectrogram_combo, /combobox_gettext)
  str = str[0]
  widget_control, idinfo.calc_spectrogram_combo, get_value = compare_str
  inx = where(str eq compare_str, count)
  if count le 0 then begin
    inx = 0
    widget_control, idinfo.calc_spectrogram_combo, set_combobox_select = inx
  endif
  info.vel_spec_window_data.calc_spectrogram = inx

; get calc_phase
  str = widget_info(idinfo.calc_phase_combo, /combobox_gettext)
  str = str[0]
  widget_control, idinfo.calc_phase_combo, get_value = compare_str
  inx = where(str eq compare_str, count)
  if count le 0 then begin
    inx = 0
    widget_control, idinfo.calc_phase_combo, set_combobox_select = inx
  endif
  info.vel_spec_window_data.calc_phase = inx

; get num_pts_per_subwindow
  str = widget_info(idinfo.num_pts_per_subwindow_vf_combo, /combobox_gettext)
  str = str[0]
  widget_control, idinfo.num_pts_per_subwindow_vf_combo, get_value = compare_str
  inx = where(str eq compare_str, count)
  if count le 0 then begin
    inx = 0
    str = compare_str[0]
    widget_control, idinfo.num_pts_per_subwindow_vf_combo, set_combobox_select = inx
  endif
  info.vel_spec_window_data.num_pts_per_subwindow_vf = long(str)

; get num_bins_to_average for spectrum of v(t) calculation
  widget_control, idinfo.num_bins_to_average_vf_text, get_value = str
  str = str[0]
  if is_valid_str_to_be_number(str) ne 1 then begin
    error_num = 300
    str_msg = bes_analyser_error_list(error_num)
    create_err_msg_window, str_msg, idinfo.base
    str = '10'
    widget_control, idinfo.num_bins_to_average_vf_text, set_value = str
  endif
  if ( (long(str) lt 1) and (info.vel_spec_window_data.calc_spectrogram eq 1) ) then begin
    error_num = 302
    str_msg = bes_analyser_error_list(error_num)
    create_err_msg_window, str_msg, idinfo.base
    str = '10'
    widget_control, idinfo.num_bins_to_average_vf_text, set_value = str
  endif
  info.vel_spec_window_data.num_bins_to_average_vf = long(str)

; get frac_overlap_subwindow for spectrum of v(t) calculation
  widget_control, idinfo.frac_overlap_subwindow_vf_slider, get_value = int_pos
  info.vel_spec_window_data.frac_overlap_subwindow_vf = float(int_pos) * 0.1

;get use_hanning_window for spectrum of v(t) calculation
  str = widget_info(idinfo.use_hanning_window_vf_combo, /combobox_gettext)
  str = str[0]
  widget_control, idinfo.use_hanning_window_vf_combo, get_value = compare_str
  inx = where(compare_str eq str, count)
  if count le 0 then begin
    inx = 0
    widget_control, idinfo.use_hanning_window_vf_combo, set_combobox_select = inx
  endif
  info.vel_spec_window_data.use_hanning_window_vf = inx

;get norm_by_DC
  str = widget_info(idinfo.norm_by_DC_combo, /combobox_gettext)
  str = str[0]
  widget_control, idinfo.norm_by_DC_combo, get_value = compare_str
  inx = where(str eq compare_str, count)
  if count le 0 then begin
    inx = 0
    widget_control, idinfo.vel_spec_window_data, set_combobox_select = inx
  endif
  info.vel_spec_window_data.norm_by_DC = inx


; save the info structure
  widget_control, idinfo.id_main_base, set_uvalue = info

end


;===================================================================================
; This procedure controls events generated by bes_vel_spec_window
;===================================================================================
; The function parameters:
;   1) 'event' is generated by the system and passed to the procedure 
;        for control purpose
;===================================================================================
pro bes_vel_spec_window_event, event

; get the user value
  widget_control, event.top, get_uvalue = idinfo

; check if called due to kill_event
  if ( (tag_names(event, /structure_name) eq 'WIDGET_KILL_REQUEST') or $ 
       (event.id eq idinfo.close_button) ) then begin
  ; update the fields
    update_bes_vel_spec_window, idinfo

  ; re-enable the ACTION buttons
    widget_control, idinfo.id_main_base, get_uvalue = info

    widget_control, info.id.main_window.basic_anal_action_button, sensitive = 1
    widget_control, info.id.main_window.dens_advanced_anal_action_button, sensitive = 1
    widget_control, info.id.main_window.vel_advanced_anal_action_button, sensitive = 1

  ; kill the window
    kill_vel_spec_window, idinfo.base

    return
  endif

; called due to BES_Ch_button
  for i = 0, 31 do begin
    if event.id eq idinfo.BES_Ch_button1[i] then begin
      button_set = widget_info(idinfo.BES_Ch_button1[i], /button_set)
      RAD_pos = i mod 8
      POL_pos = i/8
      bes_ch_button_ctrl, RAD_pos, POL_pos, button_set, $
                          idinfo.BES_Ch_button1, idinfo.POL_Ch_button1, idinfo.RAD_Ch_button1
      return
    endif
  endfor

  for i = 0, 31 do begin
    if event.id eq idinfo.BES_Ch_button2[i] then begin
      button_set = widget_info(idinfo.BES_Ch_button2[i], /button_set)
      RAD_pos = i mod 8
      POL_pos = i/8
      bes_ch_button_ctrl, RAD_pos, POL_pos, button_set, $
                          idinfo.BES_Ch_button2, idinfo.POL_Ch_button2, idinfo.RAD_Ch_button2
      return
    endif
  endfor

; called due to POL_Ch_button
  for i = 0, 3 do begin
    if event.id eq idinfo.POL_Ch_button1[i] then begin
      button_set = widget_info(idinfo.POL_Ch_button1[i], /button_set)
      bes_pol_ch_button_ctrl, i, button_set, $
                              idinfo.BES_Ch_button1, idinfo.POL_Ch_button1, idinfo.RAD_Ch_button1
      return
    endif
  endfor

  for i = 0, 3 do begin
    if event.id eq idinfo.POL_Ch_button2[i] then begin
      button_set = widget_info(idinfo.POL_Ch_button2[i], /button_set)
      bes_pol_ch_button_ctrl, i, button_set, $
                              idinfo.BES_Ch_button2, idinfo.POL_Ch_button2, idinfo.RAD_Ch_button2
      return
    endif
  endfor

; called due to RAD_Ch_button
  for i = 0, 7 do begin
    if event.id eq idinfo.RAD_Ch_button1[i] then begin
      button_set = widget_info(idinfo.RAD_Ch_button1[i], /button_set)
      bes_rad_ch_button_ctrl, i, button_set, $
                              idinfo.BES_Ch_button1, idinfo.POL_Ch_button1, idinfo.RAD_Ch_button1
      return
    endif
  endfor

  for i = 0, 7 do begin
    if event.id eq idinfo.RAD_Ch_button2[i] then begin
      button_set = widget_info(idinfo.RAD_Ch_button2[i], /button_set)
      bes_rad_ch_button_ctrl, i, button_set, $
                              idinfo.BES_Ch_button2, idinfo.POL_Ch_button2, idinfo.RAD_Ch_button2
      return
    endif
  endfor

; event due to apply_median_filter_button
  if event.id eq idinfo.apply_median_filter_button then begin
    apply_median_filter_button_set = widget_info(idinfo.apply_median_filter_button, /button_set)
    widget_control, idinfo.median_filter_width_text, sensitive = apply_median_filter_button_set
    widget_control, idinfo.apply_field_method_button, sensitive = apply_median_filter_button_set
    apply_field_method_button_set = widget_info(idinfo.apply_field_method_button, /button_set)
    if ( (apply_median_filter_button_set eq 1) and (apply_field_method_button_set eq 1) ) then begin
      widget_control, idinfo.num_time_pts_field_method_text, sensitive = 1
      widget_control, idinfo.allowed_mult_sd_text, sensitive = 1
    endif else begin
      widget_control, idinfo.num_time_pts_field_method_text, sensitive = 0
      widget_control, idinfo.allowed_mult_sd_text, sensitive = 0
    endelse

    return
  endif

; event due to apply_field_method_button
  if event.id eq idinfo.apply_field_method_button then begin
    widget_control, idinfo.num_time_pts_field_method_text, sensitive = widget_info(idinfo.apply_field_method_button, /button_set)
    widget_control, idinfo.allowed_mult_sd_text, sensitive = widget_info(idinfo.apply_field_method_button, /button_set)

    return
  endif

; event due to frac_overlap_subwindow_slider
  if event.id eq idinfo.frac_overlap_subwindow_vt_slider then begin
    widget_control, idinfo.frac_overlap_subwindow_vt_slider, get_value = int_pos
    str = string(int_pos*0.1, format='(f0.1)')
    widget_control, idinfo.frac_overlap_subwindow_vt_label, set_value = str
    return
  endif

  if event.id eq idinfo.frac_overlap_subwindow_vf_slider then begin
    widget_control, idinfo.frac_overlap_subwindow_vf_slider, get_value = int_pos
    str = string(int_pos*0.1, format='(f0.1)')
    widget_control, idinfo.frac_overlap_subwindow_vf_label, set_value = str
    return
  endif

; event due to calc_spectrogram_combo
  if event.id eq idinfo.calc_spectrogram_combo then begin
    if event.index eq 0 then begin
    ; the user selects spectrum: deactivate the num_bins_to_average_vf_text
      widget_control, idinfo.num_bins_to_average_vf_text, sensitive = 0
    endif else begin
    ; the user selects spectrogram: activate the num_bins_to_average_vf_text
      widget_control, idinfo.num_bins_to_average_vf_text, sensitive = 1
    endelse
    return
  endif

; event due to apply_median_filter_button
  if event.id eq idinfo.apply_median_filter_button then begin
    widget_control, idinfo.median_filter_width_text, sensitive = widget_info(idinfo.apply_median_filter_button, /button_set)
    return
  endif

; event due to plot_button or oplot_button
  if ( (event.id eq idinfo.plot_button) or (event.id eq idinfo.oplot_button) ) then begin
  ; check selected BES channel
    pol_dir = widget_info(idinfo.calc_pol_vel_button, /button_set)
    check_result1 = check_bes_ch_pol_rad_direction(pol_dir, idinfo.BES_Ch_button1)
    check_result2 = check_bes_ch_pol_rad_direction(pol_dir, idinfo.BES_Ch_button2)
    if check_result1 ne 0 then begin
      errmsg = bes_analyser_error_list(check_result1)
      create_err_msg_window, errmsg, idinfo.base
      return
    endif
    if check_result2 ne 0 then begin
      errmsg = bes_analyser_error_list(check_result2)
      create_err_msg_window, errmsg, idinfo.base
      return
    endif

  ; show hour glass
    widget_control, /hourglass

  ; disable the buttons
    widget_control, idinfo.plot_button, sensitive = 0
    widget_control, idinfo.oplot_button, sensitive = 0
    widget_control, idinfo.save_options_button, sensitive = 0
    widget_control, idinfo.load_options_button, sensitive = 0
    widget_control, idinfo.help_button, sensitive = 0
    widget_control, idinfo.close_button, sensitive = 0

  ; update the fields
    update_bes_vel_spec_window, idinfo

  ; plot the data
    if event.id eq idinfo.plot_button then $
      result = ctrl_plot_vel_spec(idinfo) $
    else $
      result = ctrl_plot_vel_spec(idinfo, /overplot)

    if result.erc ne 0 then begin
      create_err_msg_window, result.errmsg, idinfo.base
    endif

  ; enable the buttons
    widget_control, idinfo.plot_button, sensitive = 1
    widget_control, idinfo.oplot_button, sensitive = 1
    widget_control, idinfo.save_options_button, sensitive = 1
    widget_control, idinfo.load_options_button, sensitive = 1
    widget_control, idinfo.help_button, sensitive = 1
    widget_control, idinfo.close_button, sensitive = 1

    return
  endif

; event due to help_button
  if event.id eq idinfo.help_button then begin
;    filename = 'BES_Analyser_Dens_Spatio_Temp_Corr_Explain.pdf'
;    help_result = open_help_file(filename)
;    if help_result.erc ne 0 then begin
;      create_err_msg_window, help_result.errmsg, idinfo.base
;    endif
    return
  endif

; called due to load_options_button
  if event.id eq idinfo.load_options_button then begin
  ; set the file extension
    file_extension = '.vel_spec'
  ; get the filename
    filename = create_load_options_window(idinfo.id_main_base, file_extension)
  ; load the options
    if filename ne '' then begin
      result = load_options_info(idinfo.id_main_base, idinfo, filename, file_extension)
      if result ne 0 then begin
        errmsg = bes_analyser_error_list(result)
        create_err_msg_window, errmsg, idinfo.base
      endif
    endif

    return
  endif

; called due to save_options_button
  if event.id eq idinfo.save_options_button then begin
  ; set the file extension
    file_extension = '.vel_spec'
  ; update the fields
    update_bes_vel_spec_window, idinfo
  ; create the window
    create_save_options_window, idinfo.id_main_base, file_extension

    return
  endif

end


;===================================================================================
; This procedure updates the info field for show_flux_surface_window
;===================================================================================
; The function parameters:
;   1) 'idinfo' is a structure that is saved as uvalue under bes_vel_spec_window
;===================================================================================
pro update_show_flux_surface_window, idinfo

; get the info structure
  widget_control, idinfo.id_main_base, get_uvalue = info

; get time for flux surface
  widget_control, idinfo.time_text, get_value = str
  str = str[0]
  if is_valid_str_to_be_number(str) ne 1 then begin
    error_num = 550
    str_msg = bes_analyser_error_list(error_num)
    create_err_msg_window, str_msg, idinfo.base
    str = '0.1'
    widget_control, idinfo.time_text, set_value = str
  endif
  info.show_flux_surface_window_data.time = float(str)

; get show label
  info.show_flux_surface_window_data.show_label = widget_info(idinfo.show_label_button, /button_set)

; get contour_line_step
  widget_control, idinfo.contour_line_step_slider, get_value = int_pos
  info.show_flux_surface_window_data.contour_line_step = float(int_pos) * 0.01

; save the info structure
  widget_control, idinfo.id_main_base, set_uvalue = info

end



;===================================================================================
; This procedure controls events generated by show_flux_surface_window
;===================================================================================
; The function parameters:
;   1) 'event' is generated by the system and passed to the procedure 
;        for control purpose
;===================================================================================
pro show_flux_surface_window_event, event

; get the user value
  widget_control, event.top, get_uvalue = idinfo

; check if called due to kill_event
  if ( (tag_names(event, /structure_name) eq 'WIDGET_KILL_REQUEST') or $ 
       (event.id eq idinfo.close_button) ) then begin

  ; update the value
    update_show_flux_surface_window, idinfo

  ; re-enable the ACTION buttons
    widget_control, idinfo.id_main_base, get_uvalue = info

    widget_control, info.id.main_window.basic_anal_action_button, sensitive = 1
    widget_control, info.id.main_window.dens_advanced_anal_action_button, sensitive = 1
    widget_control, info.id.main_window.vel_advanced_anal_action_button, sensitive = 1

  ; kill the window
    kill_show_flux_surface_window, idinfo.base

    return
  endif

; event due to frac_overlap_subwindow_slider
  if event.id eq idinfo.contour_line_step_slider then begin
    widget_control, idinfo.contour_line_step_slider, get_value = int_pos
    str = string(int_pos*0.01, format='(f0.2)')
    widget_control, idinfo.contour_line_step_label, set_value = str
    return
  endif

; event due to plot button
  if event.id eq idinfo.plot_button then begin
  ; show hour glass
    widget_control, /hourglass

  ; disable the buttons
    widget_control, idinfo.plot_button, sensitive = 0
    widget_control, idinfo.close_button, sensitive = 0

  ; update the value
    update_show_flux_surface_window, idinfo

  ; plot the data
    result = ctrl_plot_flux_surface(idinfo)

    if result.erc ne 0 then begin
      create_err_msg_window, result.errmsg, idinfo.base
    endif

  ; enable the buttons
    widget_control, idinfo.plot_button, sensitive = 1
    widget_control, idinfo.close_button, sensitive = 1

    return
  endif

end


;===================================================================================
; This procedure controls events generated by bes_analyser main window
;===================================================================================
; The function parameters:
;   1) 'event' is generated by the system and passed to the procedure 
;        for control purpose
;===================================================================================
pro bes_analyser_event, event

; get the user value
  widget_control, event.top, get_uvalue = info
  id = info.id.main_window 

; check if called due to kill_event
  if ( (tag_names(event, /structure_name) eq 'WIDGET_KILL_REQUEST') or $ 
       (event.id eq id.exit_button) ) then begin
  ; close the CUDA communication line, if it is opened.
    if info.CUDA_comm_window_data.comm_line_on eq 1 then begin
      close_cuda_comm_line, info
      info.CUDA_comm_window_data.comm_line_on = 0
    endif

  ; restore the system variable
    restore_sys_var, info.sys_var.org

  ; clear the pointers
    ptr_free, info.main_window_data.BES_data.ptr_time, $
              info.main_window_data.BES_data.ptr_data, $
              info.main_window_data.plasma_current_data.ptr_time, $
              info.main_window_data.plasma_current_data.ptr_data, $
              info.main_window_data.plasma_density_data.ptr_time, $
              info.main_window_data.plasma_density_data.ptr_data, $
              info.main_window_data.SS_beam_data.ptr_time, $
              info.main_window_data.SS_beam_data.ptr_data, $
              info.main_window_data.dalpha_data.ptr_time, $
              info.main_window_data.dalpha_data.ptr_data

    widget_control, info.id.main_window.time_sel_draw, get_uvalue = plotdata
    ptr_free, plotdata.ptr_x, $
              plotdata.ptr_y, $
              plotdata.ptr_yerr, $
              plotdata.ptr_z, $
              plotdata.ptr_t

    widget_control, info.id.main_window.result_draw, get_uvalue = plotdata
    ptr_free, plotdata.ptr_x, $
              plotdata.ptr_y, $
              plotdata.ptr_yerr, $
              plotdata.ptr_z, $
              plotdata.ptr_t

  ; kill the window
    widget_control, id.main_base, /destroy
    return
  endif 

; called due to show_hide_IDL_msg_box_button event
  if event.id eq id.show_hide_IDL_msg_box_button then begin
    if info.main_window_data.IDL_msg_box_window_ON eq 1 then begin
    ; IDL_msg_box_window was ON, so kill the window
      kill_IDL_msg_box_window, info
    ; change the text on show_hide_IDL_msg_box_button
      widget_control, id.show_hide_IDL_msg_box_button, set_value = 'SHOW the IDL Message Box'
      info.main_window_data.IDL_msg_box_window_ON = 0
    endif else begin
    ; IDL_msg_box_window was OFF, so show the window
      show_IDL_msg_box_window, info.id.IDL_msg_box_window
    ; change the text on show_hide_IDL_msg_box_button
      widget_control, id.show_hide_IDL_msg_box_button, set_value = 'HIDE the IDL Message Box'
      info.main_window_data.IDL_msg_box_window_ON = 1
    endelse
  ; save the info back to main_base
    widget_control, id.main_base, set_uvalue = info

    return
  endif

; called due to ctrl_CUDA_comm_line_button event
  if event.id eq id.ctrl_CUDA_comm_line_button then begin
    show_CUDA_comm_window, info.id.CUDA_comm_window

    return
  endif

; called due to time_sel_window_option_button
  if event.id eq id.time_sel_window_option_button then begin
    show_time_sel_window, info.id.time_sel_window

    return
  endif

; called due to load_data_button or a user pressed 'Enter' key on the shot_number_text
;  Load the data for time_selection plot
  if ( (event.id eq id.load_data_button) or (event.id eq id.shot_number_text) ) then begin
    widget_control, /hourglass
    widget_control, id.load_data_button, sensitive = 0
    update_time_sel_window, info
    load_result = load_data_for_time_sel_win(info)
    widget_control, id.load_data_button, sensitive = 1

    if load_result.erc eq 0 then begin
    ; no error occured.  plot the data.
      result = plot_time_sel_window(info)	; plot the data on the time_sel_window
      if result.erc ne 0 then begin
        create_err_msg_window, result.errmsg, id.main_base
      endif
    endif else if load_result.erc eq 1 then begin
    ; error occured.  but not fatal errors.
    ; show a warning message, then plot the data.
      create_err_msg_window, load_result.errmsg, id.main_base
      result = plot_time_sel_window(info)	; plot the data on the time_sel_window
      if result.erc ne 0 then begin
        create_err_msg_window, result.errmsg, id.main_base
      endif
    endif else begin
    ; fatal error occured.
    ; plot cannot be performed.
      create_err_msg_window, load_result.errmsg, id.main_base
      return
    endelse

    return
  endif

; called due to time_sel_zoom_button
  if event.id eq id.time_sel_zoom_button then begin
    if widget_info(id.time_sel_zoom_button, /button_set) eq 1 then begin
      str = '            Zoom: Hold LEFT button,  Pan: Hold MIDDLE button,  Reset: Press RIGHT button             '
      widget_control, id.time_sel_label, set_value = str
    endif else begin
      str = '          Select: Hold LEFT button,  Deselect: Press RIGHT button,  Pan: Hold MIDDLE button          '
      widget_control, id.time_sel_label, set_value = str
    endelse
    return
  endif

; called due to time_sel_draw
  if event.id eq id.time_sel_draw then begin
    widget_control, id.time_sel_draw, get_uvalue = plotdata
    if plotdata.curr_num_plots gt 0 then $
      bes_analyser_mouse_event, event, info
    return
  endif

; called due to result_draw
  if event.id eq id.result_draw then begin
    widget_control, id.result_draw, get_uvalue = plotdata
    if plotdata.curr_num_plots gt 0 then $
      bes_analyser_mouse_event, event, info
    return
  endif

; called due to basic_anal_action_button
  if event.id eq id.basic_anal_action_button then begin
  ; disable the all action buttons, and enable them again when the created option window is killed.
    widget_control, id.basic_anal_action_button, sensitive = 0
    widget_control, id.dens_advanced_anal_action_button, sensitive = 0
    widget_control, id.vel_advanced_anal_action_button, sensitive = 0

  ; check which buttons are selected
    if widget_info(id.bes_time_evol_button, /button_set) eq 1 then begin
    ; create an option window to plot time evolutino of raw BES signal
      create_bes_time_evol_window, id.main_base
      return
    endif

    if widget_info(id.bes_rms_dc_ratio_button, /button_set) eq 1 then begin
    ; create an option window to plot RMS/DC values of the BES signal
      create_bes_rms_dc_time_evol_window, id.main_base
      return
    endif

    if widget_info(id.bes_movie_button, /button_set) eq 1 then begin
    ; create an option window to plot animation of BES signal
      create_bes_animation_window, id.main_base
      return
    endif

    if widget_info(id.bes_flux_pos_button, /button_set) eq 1 then begin
    ; create an option window to plot flux surface
      create_show_flux_surface_window, id.main_base
      return
    endif

  endif

; called due to dens_advanced_anal_action_button
  if event.id eq id.dens_advanced_anal_action_button then begin
  ; disable the all action buttons, and enable them again when the created option window is killed.
    widget_control, id.basic_anal_action_button, sensitive = 0
    widget_control, id.dens_advanced_anal_action_button, sensitive = 0
    widget_control, id.vel_advanced_anal_action_button, sensitive = 0

    if widget_info(id.dens_spectrum_button, /button_set) eq 1 then begin
    ; create an option window to plot density spectrum of BES signal
      create_dens_spec_window, id.main_base
      return
    endif

    if widget_info(id.dens_coherency_button, /button_set) eq 1 then begin
    ; create an option window to plot density coherency of BES signal
      create_dens_coh_window, id.main_base
      return
    endif

    if widget_info(id.dens_temporal_corr_button, /button_set) eq 1 then begin
    ; create an option window to plot denity temporal correlation of BES signal
      create_dens_temporal_corr_window, id.main_base
      return
    endif

    if widget_info(id.dens_spatial_corr_button, /button_set) eq 1 then begin
      err_num = 1000
      msg_str = bes_analyser_error_list(err_num)
      create_err_msg_window, msg_str, id.main_base

      widget_control, id.basic_anal_action_button, sensitive = 1		;this is temporary line
      widget_control, id.dens_advanced_anal_action_button, sensitive = 1	;this is temporary line
      widget_control, id.vel_advanced_anal_action_button, sensitive = 1		;this is temporary line

      return
    endif

    if widget_info(id.dens_spatio_temp_corr_button, /button_set) eq 1 then begin
    ; create an option window to plot density spatio-temporal correlation of BES signal
      create_dens_spa_temp_corr_window, id.main_base
      return
    endif

    if widget_info(id.dens_spatio_spatio_corr_button, /button_set) eq 1 then begin
    ; create and option window to plot density spatio-spatio correlation of BES signal
      create_dens_spatio_spatio_corr_window, id.main_base
      return
    endif

    if widget_info(id.dens_bispec_button, /button_set) eq 1 then begin
      err_num = 1000
      msg_str = bes_analyser_error_list(err_num)
      create_err_msg_window, msg_str, id.main_base

      widget_control, id.basic_anal_action_button, sensitive = 1		;this is temporary line
      widget_control, id.dens_advanced_anal_action_button, sensitive = 1	;this is temporary line
      widget_control, id.vel_advanced_anal_action_button, sensitive = 1		;this is temporary line

      return
    endif

    if widget_info(id.dens_bicoherency_button, /button_set) eq 1 then begin
      err_num = 1000
      msg_str = bes_analyser_error_list(err_num)
      create_err_msg_window, msg_str, id.main_base

      widget_control, id.basic_anal_action_button, sensitive = 1		;this is temporary line
      widget_control, id.dens_advanced_anal_action_button, sensitive = 1	;this is temporary line
      widget_control, id.vel_advanced_anal_action_button, sensitive = 1		;this is temporary line

      return
    endif

  endif

; called due to vel_advanced_anal_action_button
  if event.id eq id.vel_advanced_anal_action_button then begin
  ; disable the all action buttons, and enable them again when the created option window is killed.
    widget_control, id.basic_anal_action_button, sensitive = 0
    widget_control, id.dens_advanced_anal_action_button, sensitive = 0
    widget_control, id.vel_advanced_anal_action_button, sensitive = 0

    if widget_info(id.vel_time_evol_button, /button_set) eq 1 then begin
    ; create an option window to plot time evolution of velocity
      create_vel_evol_window, id.main_base
      return
    endif

    if widget_info(id.vel_spectrum_button, /button_set) eq 1 then begin
    ; create an option window to plot velocity spectrum
      create_vel_spec_window, id.main_base
      return
    endif

    if widget_info(id.vel_coherency_button, /button_set) eq 1 then begin
      err_num = 1000
      msg_str = bes_analyser_error_list(err_num)
      create_err_msg_window, msg_str, id.main_base

      widget_control, id.basic_anal_action_button, sensitive = 1		;this is temporary line
      widget_control, id.dens_advanced_anal_action_button, sensitive = 1	;this is temporary line
      widget_control, id.vel_advanced_anal_action_button, sensitive = 1		;this is temporary line

      return
    endif

    if widget_info(id.vel_temporal_corr_button, /button_set) eq 1 then begin
      err_num = 1000
      msg_str = bes_analyser_error_list(err_num)
      create_err_msg_window, msg_str, id.main_base

      widget_control, id.basic_anal_action_button, sensitive = 1		;this is temporary line
      widget_control, id.dens_advanced_anal_action_button, sensitive = 1	;this is temporary line
      widget_control, id.vel_advanced_anal_action_button, sensitive = 1		;this is temporary line

      return
    endif

    if widget_info(id.vel_spatial_corr_button, /button_set) eq 1 then begin
      err_num = 1000
      msg_str = bes_analyser_error_list(err_num)
      create_err_msg_window, msg_str, id.main_base

      widget_control, id.basic_anal_action_button, sensitive = 1		;this is temporary line
      widget_control, id.dens_advanced_anal_action_button, sensitive = 1	;this is temporary line
      widget_control, id.vel_advanced_anal_action_button, sensitive = 1		;this is temporary line

      return
    endif

    if widget_info(id.vel_spatio_temp_corr_button, /button_set) eq 1 then begin
      err_num = 1000
      msg_str = bes_analyser_error_list(err_num)
      create_err_msg_window, msg_str, id.main_base

      widget_control, id.basic_anal_action_button, sensitive = 1		;this is temporary line
      widget_control, id.dens_advanced_anal_action_button, sensitive = 1	;this is temporary line
      widget_control, id.vel_advanced_anal_action_button, sensitive = 1		;this is temporary line

      return
    endif

  endif

; called due to show_time_indicator_button
  if event.id eq id.show_time_indicator_button then begin
    if widget_info(id.show_time_indicator_button, /button_set) eq 1 then $
      widget_control, id.result_draw_slider, sensitive = 1 $
    else $
      widget_control, id.result_draw_slider, sensitive = 0
    draw_timeline, info, /by_slider
    return
  endif

; called due to result_draw_slider
  if event.id eq id.result_draw_slider then begin
    draw_timeline, info, /by_slider
    return
  endif

; called due to make_inde_plot_button
  if event.id eq id.make_inde_plot_button then begin
  ; get plotdata from the result window
    widget_control, info.id.main_window.result_draw, get_uvalue = plotdata

  ; if there is no data, then return
    if plotdata.curr_num_plots lt 1 then $
      return

  ; get the shot number
    str_shotnumber = 'Shot #' + string(info.main_window_data.bes_data.shot, format='(i0)') + ': '

  ; check the dimension of the data
    plot_dim = fix(alog10(plotdata.type)) + 1

    if plot_dim eq 2 then begin
      for i = 0, plotdata.curr_num_plots - 1 do begin
        x = *plotdata.ptr_x[i]
        y = *plotdata.ptr_y[i]
        if plotdata.type eq 26 then begin
          yerr = fltarr(2, n_elements(x))
          yerr[0, *] = reform(*plotdata.ptr_yerr[0, i])
          yerr[1, *] = reform(*plotdata.ptr_yerr[1, i])
        endif
        if i eq 0 then begin
          if plotdata.type eq 26 then begin
            ycplot, x, y, error = yerr, title = str_shotnumber + plotdata.title, xtitle = plotdata.xtitle, ytitle = plotdata.ytitle, $
                    xlog = plotdata.xlog, ylog = plotdata.ylog, out_base_id = oplotid
          endif else begin
            ycplot, x, y, title = str_shotnumber + plotdata.title, xtitle = plotdata.xtitle, ytitle = plotdata.ytitle, $
                    xlog = plotdata.xlog, ylog = plotdata.ylog, out_base_id = oplotid
          endelse
        endif else begin
          if plotdata.type eq 26 then begin
            ycplot, x, y, error = yerr, oplot_id = oplotid
          endif else begin
            ycplot, x, y, oplot_id = oplotid
          endelse
        endelse
      endfor
    endif else if plot_dim eq 3 then begin
      x = *plotdata.ptr_x[0]
      y = *plotdata.ptr_y[0]
      z = *plotdata.ptr_z[0]
      ycshade, z, x, y, title = str_shotnumber + plotdata.title, xtitle = plotdata.xtitle, ytitle = plotdata.ytitle, ztitle = plotdata.ztitle, $
               zlog = plotdata.zlog, plot_pos = plotdata.shade_pos, scale_pos = plotdata.scale_pos, $
               ctable_num = plotdata.inx_ctable, ctable_invert = plotdata.inv_ctable
    endif else if plot_dim eq 4 then begin
      x = *plotdata.ptr_x[0]
      y = *plotdata.ptr_y[0]
      z = *plotdata.ptr_z[0]
      t = *plotdata.ptr_t[0]
      ycshade, z, x, y, t, title = str_shotnumber + plotdata.pre_title, xtitle = plotdata.xtitle, ytitle = plotdata.ytitle, ztitle = plotdata.ztitle, $
               zlog = plotdata.zlog, plot_pos = plotdata.shade_pos, scale_pos = plotdata.scale_pos, $
               ctable_num = plotdata.inx_ctable, ctable_invert = plotdata.inv_ctable, curr_inx_tframe = plotdata.inx_curr_time
    endif

    return
  endif


end